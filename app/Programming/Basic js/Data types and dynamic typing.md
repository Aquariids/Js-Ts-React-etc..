[Динамическая типизация в JavaScript](#dinamic)<br>
[Неявное приведение типов данных]()<br>
[Проверка на тип данных](#typeof)<br>
[Примитивные типы данных в Javascript](#DataTypes)<br>
[Комплексный тип данных 'Object'](#Object)<br>



## <a name ='DataTypes'> Типы данных </a> ## 

Для проверки переменных и значений на их тип данных, в js есть метод typeof(тут переменная или значение)
```javascript
'use strict';

let num = 10;

console.log(typeof(num)) // number
console.log(typeof('строка')); // string
```
Далее я буду пользоваться этим методом для наглядной демонстрации типа данных.

В js существует восемь типов данных. Из них семь примитивов и один комплексный, более сложный тип данных(объект)
### Примитивы ###
Примитив - это тип данных с простым значениям, строка, число, булевое значение и тд.<br>
Разберем все по порядку.

#### 1.Числа(numbers) ####
Это обычные цифры, числа. Максимальное допустимое число для безопасной работы в javaScript 2<sup>53</sup> степени.
Так же кроме обычных чисел есть специальные значения: Infinity, -Infinity и NaN.
```javascript
'use strict';

let numbers = 12;

console.log(typeof(numbers)); //number
```
infinity и -infinity (Бесконечность):
```javaScript
'use strict';

console.log(4 / 0); // Infinity
console.log(-4 / 0); // -Infinity
```
NaN(Not a Number)<br>
NaN будем получать при ошибочных метематических операциях. Например умножаем то, что нельзя умножать:
```javaScript
'use strict';

console.log(4 * 's')// NaN
Умножаем число на строку, получаем NaN(не число) 
```
#### 2.Строки(String) ####
Строки всегда в одинарных или двойных кавычках '' "".
```javascript
'use strict';

let str = 'привет'
let str2 = '12' // это строка

console.log(typeof(str)); // string
```
#### 3.Логический тип(boolean) ####
Булевый тип принимает только два значения: true(истина) и false(ложь).
```javascript
'use strict';

let booleanTypes1 = true; 
let booleanTypes2 = false;

console.log(typeof(booleanTypes1,booleanTypes2)); // boolean
```
#### 4.Тип данных(null) ####
null - это отдельный тип данных, который содержит в себе только null. Он подразумевает отсутствие объектного значения.
null - это простой тип данных, но при этом от null унаследованы все объекты. Если проверять тип null то выдаст 'object'.
```javascript
'use strict';

let a = null;
console.log(a); // null
```
Если в typeof добавить null, то он выведет object - это ошибка, но куда без них.
#### 5.Тип Данных(undefined) ####
undefiend - присваивается переменным, которые были только объявлены, без значения. Так же аргументам в функциях, для которых не были установлены значения.
```javascript
'use strict';

let a;
console.log(a); // undefined
function f1 (a,b) {
    console.log(a);
}

f1(); //undefined
```
#### 6.Символ(Symbol) ####
Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
Я его еще не изучал, так шо сории.

#### 7.Тип данных BigInt ####
BigInt позволяет работать с числами больше чем 2<sup>53</sup>степени.
BigInt создаётся путём добавления n в конец целочисленного литерала 
```javascript
'use strict';

let theBiggestInt = 9007199254740991n;
let alsoHuge = BigInt(9007199254740991);
// документация MDN привет
```

## Комплексный тип данных (Object) ##                                  
  Объект - это структура данных которая может иметь в себе разные данные. Именно потому что объект может содержать в себе разные конструкции, он не относится к примитивам.
  При этом эти данные могут быть разного типа, это благодаря динамической типизации языка.(О ней будет ниже)
  ```javaScript
  'use strict';
  
    // этот объект содержит в себе определенные свойства(своеобразные переменные).
   // Любое свойство подразумевает пару "ключ(имя):значение(что угодно)", обязательно ставим двоеточие.
   
   const obj = {  // Создав переменную просто открываем фигурные скобки {}. Так, мы создали объект. 
     name: 'Dima',  // свойство  с именем name со значением Dima
     age: 24, // свойство с именем age со значением 24 и тд
     watchAnime: true 
  }
  // проверим на тип данных
  console.log(typeof(obj));// object
  // Что бы обратиться к свойству в объекте, пишем имя объекта и через точку свойство. Проверим тип данных свойства name
  console.log(typeof(obj.name)); // string ('Dima' - это строка)
  ```
  Комплексный он потому что на основе объекта могут быть разные конструкции(Специальные объекты)
  
  ### Специальные объекты ###
  #### 1.Массив ####
  Массив это частный случай объекта. Он как бы в своей основе объект, но немного с другим поведением. Все данные хранятся строго по порядку!
  ```javaScript
  'use strict';
  
  const arr = ['ss', 1, {}, []]; // Массив так же может содержать в себе разные типы.
  
// Но здесь есть только значения, а Его ключи они фиксированны и идут строго по порядку от 0 - это индекс(позиция элемента)
// Например строка 'ss' - она первая и ее индекс(позиция) будет 0, далее число 1 с индексом 1 и так далее.
// В программировании все начинается с 0 (Первый элемент это всегда позиция 0).
// проверим позицию элемента (просто указываем массив и нужный индекс в квадратных скобках []).

console.log(arr[0]); // нам выдаст 'ss'

// проверим тип данных массива

console.log(typeof(arr)); // object

// проверим тип данных элемента под индексом 0

console.log(typeof(arr[0])); // string (потому что там строка 'ss')
  ```
  #### 2.Функции ####

О  работе функциях я буду говорить не здесь. Пока просто проверим тип данных функции.
Мы получим function. Это техническая часть, углубляться пока что нет смысла. Но функция это специальный объект, просто так же имеет свой специальный тип вот и все.
```javaScript
'use strict';

const f1 function () {
return;
};

console.log(typeof(f1)) // function
```


#### Объект даты ####
С объектом даты так же будем работать позже.
``` javaScript
'use strict';

let now = new Date();

console.log(typeof(now)); // object
```
#### Регулярные выражения и ошибки ####
И с этими понятиями познакомимся позже
```javaScript 
'use strict';

let reg = /i/g // регулярное выражение

console.log(typeof(reg)); // object

let err = new Error();

console.log(typeof(err)); // object
```

<a name ='dinamic'> Динамическая типизация </a> ## 
Типизация - подразумевает классификацию типов данных.<br>
Динамическая типизация - это когда тип данных задается(классифицируется) при присваивании значения:

```javaScript
let num = 1; // JavaScript понимает, что здесь тип данных числовой, при добавлении в переменную значения.
// Это и есть Динамическая типизация, то есть она меняется в динамике.
```
Так же стоит упомянуть, что есть статическая типизация.<br>
Статическая типизация - это когда язык проверяет тип данных в программе во время компиляции, еще до запуска программы. 
То есть мы указываем тип во время объявления переменной<br>


## Неявное приведение типов в JavaScript ##
Так же динамическая типизация подразумевает неявное приведение типов. 
Неявнное приведение типов - это автоматическое приведение типа, выполняемое компилятором.
То есть когда мы это делаем неявно, не каким то специальным методом.

#### 1.String ####
Привести к строке можно с помощью конкатенации.<br>
Конкатенация - сложение строк или строки с чем то(просто ставим +).        
```javaScript
console.log(typeof(5 + '')); // string
// Мы сложили число с пустой строкой. В итоге получили '5' - строку
console.log(typeof(undefined + '')); //string 
// Получили  'undefined' - строка
// так же можно и не с пустой строкой. Допустим добавляем через js какие то стили и нам нужно 25px
console.log(25 + 'px')); // 25px - это строка
```
Пустые массивы в операциях с конкатенацией равняются путой строке
```javaScript
 console.log(typeof([]+[])); // string
 console.log([] + 5); // даст строку '5'
 console.log(typeof({}+{})); // string
 // объект тоже превращает в строку. Но при конкатенации объект не равен пустой строке, он будет выдавать [object Object] (просто строчное представления объекта)
 console.log({} + 5); // [object Object]5
  //  Это все приведет к строке и типу данных string. Но не получится как с помощью массива превратить 5 в "5".
```
        
      
#### 2.Numbers ####                                  
//  2)  Унарный + 
        console.log(typeof(+ '5')); // number
//  3)  parseInt() 1 - аргумент это строка, а 2 - система исчесления
        console.log(parseInt('15px', 10)); // 15(число)
        // Пример Унарного плюса
        let answ = +prompt('hello',''); // ВСЕ ЧТО МЫ ПОЛУЧАЕМ ОТ ПОЛЬЗОВАТЕЛЯ - ЭТО СТРОКИ
        // если здесь введут число, то мы его преобразуем из строки в тип число
        // если ведут буквы, то будет NaN
//                                         0.3-To boolean превращаем в логический тип
  // 1) первый такой нативный способ!
/** Все что превращается в false!!
 *  - 0 = ноль
 *  - '' = Пустота
 *  - null = null
 *  - undefined = андефаинд
 *  - NaN = Not a Number
 *  Все остальное будет true */
 // Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {} 
  
  if ({} && []) {
   console.log("Все объекты - true!"); // alert сработает
  } 

  // Пример:
  let switcher = null; // null = false

  if (switcher) { // не сработает
    console.log('working...');
  }

  switcher = 1; // 1  В логическом контексте = true (не только 1, любая цифра или число кроме 0)

  if (switcher) { // работает
    console.log('working...');
  }

  // 2)  как и с строкой и числом и тоже супер редкий
        console.log(typeof(Boolean('4'))); // boolean
  // 3) !! - два знака отрицания
  console.log(typeof(!!'42432')); // boolean

/*
