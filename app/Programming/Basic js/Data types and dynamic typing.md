[Проверка на тип данных]<br>
[Типы данных в javascript]


## [Метод для проверки типа данных] ##
Для проверки переменных и значений на их тип данных, есть метод typeof(тут переменная или значение)
```javascript
let num = 10;

console.log(typeof(num) // number
console.log(typeof('строка')); // string
```
Далее я буду пользоваться этим методом для наглядной демонстрации типа данных.

## [Типы данных] ##
В js существует восемь типов данных. Из них семь примитивов и один комплексный, более сложный тип данных(объект)
### Примитивы ###
Примитив - это тип данных с простым значениям, строка, число, булевое значение и тд.<br>
Разберем все по порядку.

#### 1.Числа(numbers) ####
Это обычные цифры, числа. Максимальное допустимое число в js - 2<sup>53</sup>степени.
Так же кроме обычных чисел есть специальные значения: Infinity, -Infinity и NaN.
```javascript
let numbers = 12;

console.log(typeof(numbers)); //number
```
infinity и -infinity (Бесконечность):
```javaScript
console.log(4 / 0); // Infinity
console.log(-4 / 0); // -Infinity
```
NaN:(Not a Number): NaN будем получать при ошибочных метематических операциях
```javaScript
console.log(4 * 's')// NaN
Умножаем число на строку, получаем NaN(не число) 
```

#### 2.Строки(String) ####<br>
Строки всегда в одинарных или двойных кавычках '' "".
```javascript
let str = 'привет'
let str2 = '12' // это строка

console.log(typeof(str)); // string
```
#### 3.Логический тип(boolean) ####<br>
Булевый тип принимает только два значения: true(истина) и false(ложь).
```javascript
let booleanTypes1 = true; 
let booleanTypes2 = false;

console.log(typeof(booleanTypes1,booleanTypes2)); // boolean

```
#### 4.Тип данных(null) ####<br>
null - это отдельный тип данных, который содержит в себе только null. Он подразумевает отсутствие объектного значения.
null - это простой тип данных, но при этом от null унаследованы все объекты. Если проверять тип null то выдаст 'object'.
```javascript
let a = null;
console.log(a); // null
```
Если в typeof добавить null, то он выведет object - это ошибка, но куда без них.
#### 5.Тип Данных(undefined) ####<br>
undefiend - присваивается переменным, которые были только объявлены, без значения. Так же аргументам в функциях, для которых не были установлены значения.
```javascript
let a;
console.log(a); // undefined
function f1 (a,b) {
    console.log(a);
}

f1(); //undefined
```
#### 6.Символ(Symbol) ####
Тип symbol (символ) используется для создания уникальных идентификаторов в объектах.
Я его еще не изучал, так шо сории.

#### 7.Тип данных BigInt ####<br>
BigInt позволяет работать с числами больше чем 2<sup>53</sup>степени.
BigInt создаётся путём добавления n в конец целочисленного литерала 
```javascript
let theBiggestInt = 9007199254740991n;
let alsoHuge = BigInt(9007199254740991);
// документация MDN привет
```                                      2.1-ЕЩЕ ЕСТЬ ЧИСЛОВЫЙ ТИП ДАННЫХ ИФИНИТИ и NaN (примитив!)



const nAn = NaN; // not a number (короче если всякую хуету с числами мутишь, 
// то, будет такая шляпа. Умножаешь, то, что нельзя умножать и тд)
console.log('string' * 19); // NaN




 /*                                    3-Комплексный тип данных (ОБЪЕКТЫ)  */

/*                                      3.1-СПец Объекты  */
/*                                      3.2-МАССИВЫ */

const arr = ['ss', 1, {}, []]; // - массивы частный случай объекта!
/* А с хуя это частный случай объекта? а вот с того, что здесь такие же
    знаения и ключи, просто тут  ключи фиксированные!  
    массивы нужны для того, что бы строго по порядку распологать элементы
    если написать индекс эелемента, то увидим, что это очень похоже на объект
        просто ключ фиксированный! */
0   1  2  3
const arr = ['ss', 1, {}, []];
//хранит любой тип данных
//хранит данные строго по порядку!

console.log(arr[0]); // 'ss' - так мы берем из массива нужный элемент,
//через индекс. нумерация в прогр начинается с 0 -  первый элемент!!!


/*                                  3.3-Функции! */

let fun = function () { };

() => {

};
function func() { }; // ну вы поняли))))

/* Объект Даты */
let now = new Date();

/* регулярные выражения! и ошибки! */

//                                  3.4-ОБЫЧНЫЕ ОБЪЕКТЫ

let obj = {
    // Описываем объект ключ: значение!
    // ключ - это свойство, а после : Значение этого свойства!      
    /*  свойство объекта(name) и значение('димка')! - */
    name: 'димка',
    age: 24,
    gay: false

};

console.log(obj.name); // через точку обращаемся к свойству! или же [''], но лучше точка






 */

//                                         0.1-To String! Превращаем в строку

 // 1) Самый старый и редкий вариант
        console.log(typeof(String(null))); // string
        // Можем запустить без typeof  и нам выдаст null - но это будет строка!!!!
        console.log(String(4)); // 4 - строка!
        

//  2) Конкатенация - сложение строк или строки с чем то
        console.log(typeof(5 + '')); // string
        // Мы сложили число с пустой строкой
        console.log(typeof(undefined + '')); // string
        // Пустые массивы в операциях с конкатенацией равняются путой строке
        console.log(typeof([]+[])); // string
        console.log(typeof({}+{})); // string // объект тоже превращает в строку
        console.log([] + 5); // даст строку 5
        console.log({} + 5); // даст вот такую строку [object Object]5
        // при конкатенации объект не совсем равен пустой строке. Это все приведет к строке и типу данных
        // но не получится как с помощью массива превратить 5 в "5"

        // Пример старого кода!
        const num = 5;
        console.log('http://vk.com/catalog' + num); // Вот нам нужно создать путь(Сейчас для этого есть интерполяция)
        //  нам нужна строка, вот мы ее и получаем с помощью конкатенации
        const fontSize = 26 + 'px'; // вот характеристика для стилей например
        console.log(fontSize); // 26px
//                                        0.2-To Number  Превращаем в число

//  1) Так же как и с строкой( даже реже чем String)
        console.log(typeof(Number('4'))); // number
//  2)  Унарный + 
        console.log(typeof(+ '5')); // number
//  3)  parseInt() 1 - аргумент это строка, а 2 - система исчесления
        console.log(parseInt('15px', 10)); // 15(число)
        // Пример Унарного плюса
        let answ = +prompt('hello',''); // ВСЕ ЧТО МЫ ПОЛУЧАЕМ ОТ ПОЛЬЗОВАТЕЛЯ - ЭТО СТРОКИ
        // если здесь введут число, то мы его преобразуем из строки в тип число
        // если ведут буквы, то будет NaN
//                                         0.3-To boolean превращаем в логический тип
  // 1) первый такой нативный способ!
/** Все что превращается в false!!
 *  - 0 = ноль
 *  - '' = Пустота
 *  - null = null
 *  - undefined = андефаинд
 *  - NaN = Not a Number
 *  Все остальное будет true */
 // Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {} 
  
  if ({} && []) {
   console.log("Все объекты - true!"); // alert сработает
  } 

  // Пример:
  let switcher = null; // null = false

  if (switcher) { // не сработает
    console.log('working...');
  }

  switcher = 1; // 1  В логическом контексте = true (не только 1, любая цифра или число кроме 0)

  if (switcher) { // работает
    console.log('working...');
  }

  // 2)  как и с строкой и числом и тоже супер редкий
        console.log(typeof(Boolean('4'))); // boolean
  // 3) !! - два знака отрицания
  console.log(typeof(!!'42432')); // boolean

/*                                          0-Динамическая типизация и статическая! */


// (Динамическая типизация это возможность одного типа данных превращаться в другой
// Число может стать строкой, строка числом) 
// объект может стать boolean значением. Подробнее ниже.
/*
