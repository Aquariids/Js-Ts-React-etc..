[Массивы](#arr)<br>
[Подробнее о length](#length)<br>
[Методы массива](#methods)<br>
[Перебираем массив](#for)<br>
[Деструктуризация массива]()<br>
[Псевдо массивы]()<br>

## <a name ='arr'> Массивы </a> ## 
Массив - это структура которая содержит элементы строго по порядку. Для создания массива использоются квадратные [] скобки.
Обращаться к элементам можно через их индекс(Позиция), начинается от 0.
```javaScript
const arr = [1,2,3,8,9]; // все в квадратныых скобках - массив

// Мы выбрали 0 индекс - первый элемент
console.log(arr[0]); // 1

// Так же работают и строки.
console.log('012345'[4]); // 4
// мы указали строку и сразу рядом использовали [] скобки, что бы указать индекс в этой же строке.
```

## <a name ='length'> length в массивах </a> ##
length состоит из последнего индекса указываемого массива и прибавляет + 1.
```javaScript
const arr = [1,2,3,8,9];  // индекс последнего элемента 4
// что сделал length? Он взял последний индекс и прибавил к нему 1 
console.log(arr.length); // выдаст нам 5
```
Немного сломаем length для примера его работы:
```javaScript
const arr = [1,2,3,8,9];  // мы имеем все тот же массив
arr[99] = 0; // присваиваем на позицию 99 ноль. У нас такого индекса нет, но теперь он появится со значением 0

console.log(arr.length); // выдает 100, потому что length взяло последний индекс и +1 прибавило.
console.log(arr); // [ 1, 2, 3, 8, 9, <94 empty items>, 0 ] - вот как выглядит наш массив. 6 элементов и 94 пустых ячейки.
// у нас было 5 элементов на позициях от 0 до 4, потом идет 94 пустых ячейки и на 99 у нас наш 0. 
```
## <a name = 'methods'> Методы массива </a> ##

### pop( ) ###
pop( ) -  удаляет последний элемент из массива.
```javaScript
const arr = [1,2,3,4,5];
arr.pop();
console.log(arr); // [ 1, 2, 3, 4 ];
```

### push( ) ### 
push( ) - добавляет элемент в конец массива.
```javaScript
const arr = [1,2,3,4,5];
arr.push(9);
console.log(arr); // [ 1, 2, 3, 4, 5, 9];
```
### shift( ) и unshift(...items) ###
shift( ) - извлекает элемент из начала массива.<br>
unshift( ) - добавляет элемент в начало.<br>
Эти методы в реальных проектах используются редко, так как после их использования индексы смещаются.
```javaScript
const arr = [0,1,2,3,4,5];
arr.shift();

console.log(arr); // [1, 2, 3, 4, 5] - Теперь под индексом 0 у нас 1, а не 0 как было.
```
```javaScript
const arr = [0,1,2,3,4,5];
arr.unshift(10);

console.log(arr) //  [10, 0, 1, 2, 3, 4, 5]; - теперь под индексом 0 у нас 10, а не 0.
```
### split( ) ###
split( 'тут разделитель' ) - разбивает строчку на массив строк путём разделения указанным разделителем.
```javaScript
const str = 'п,р,и,в,е,т';
const products = str.split(','); // здесь мы указали (,) и если строки будут через (,) то они образуют массив
console.log(products); // [ 'п', 'р', 'и', 'в', 'е', 'т' ]
```
Мы сформировали на основании строки, массив, так же мы можем сделать и на оборот с помощью join( ).
### join( ) ###
join( 'тут разделитель' ) - объеденяет элементы массива.    
```javaScript
const str = 'п,р,и,в,е,т';
const products = str.split(',');
// join() - собрал массив в строку через '' путсую строку, что в итоге нам дало строчку 'привет'
console.log(products.join('')); // привет
// Еще примерчик. Поставим точку как разделитель.
console.log(products.join('.')); // п.р.и.в.е.т
```
### sort( ) ###
sort( ) - метод сортировки. Eсли мы его просто применим в таком виде .sort( ) то он отсортирует все по алфавиту, если это массив из строчных элементов
```javaScript
const arr = ['b','s','c','g','t','a','h','u'];
console.log(arr.sort());
/*  Получим такой массив по алфовиту
[
  'a', 'b', 'c',
  'g', 'h', 's',
  't', 'u'
]
*/
```
А что будет если массив будет из цифр?
```javaScript
const arrNew = [2,13,26,8,10];
arrNew.sort();
console.log(arrNew); // вот что мы получим [10, 13, 2, 26, 8] - фишка в том, что sort все сортирует как строки.
 // Все числа начинающиеся с 1 (если бы был 0 - он был бы первым) встали на первое место далее сравниваются вторые числа
 // Идет 10 и 13. первыми сравниваются 1 и 1, далее 0 и 3, 0 меньше чем 3, по этому 10 впереди.
 // Далее идут все что начинается на 2, то есть сама 2.
 // Потом 26 и 8 - самое большое. Все отсортировалось как строки. по сути сравнивается каждая отдельная цифра от числа, а не число целиком.
```
Способ как этого избежать:
```javaScript
// Для этого передадим в  sort( ) колбек функцию
const arrNew = [2,13,26,8,10];
console.log(arrNew.sort(compareNum)) // [2, 8, 10, 13, 26] Все отсортировалось как нужно

function compareNum (a, b) { 
        return a - b;
 }
```
Как это работает я пока не знаю. Просто пользуемся))
## <a name = 'for'> Перебираем массив с помощью for, forEach или for of </a> ##

// 1) for 

for (let i = 0; i < arr.length; i++) {   // в обычном for создаем i c 0(индекс), потом указываем в условии, что юзать будет 
//                                          до тех пор пока i меньше arr.length( кол элементов в массиве)
    console.log(arr[i]); // здесь обращаемся к i в массиве. сначала в i = 0 - мы обратимся к 1 элементу
    //                            потом  i++ (ув на 1 ед) и тогда уже обратимся ко второму элементу и так далее пока не выполнится условие
    //                               пока не закончатся все элементы (i < arr.length)
}

// 2) for of

for (let value of arr) {    // создаем переменную, в ней будет храниться каждый элемент массива, обычно называют ее value
//              Далее указываем массив в котором будем работать
    console.log(value);
} // Такая конструкция работает только с массиво подобными сущностями
// можем перебрать массив, псевдоМассив, строку и тд
// так же у for of есть преимущество перед forEach. Здесь можно использовать breake и continue

const arrTwo = ['piska', 2,1, 5, 3,];


//  3) forEach () - Это кстати метод и его фишка в том,что его можно подробнее настроить
// forEach принимает в себя еще одну функцию, так как метод это функция то выходит, что наша функция внутри это - (callback)
// так же метод forEach () есть у псевдомассива получаемым с помощью querySelectorAll()
arrTwo.forEach (function (item, i , arrTwo) { // callback функция может принимать в себя 3 аргумента
    // 1 - тот элемент, что перебираем
    // 2 - это номер по порядку (индекс)
    // 3 - это ссылка на тот массив который перебираем
        // наша функция внунтри будет выполняться для каждого элемента массива
        // forEach будет проходить по каждому элементу и применять эту функцию

        console.log(`${i}: ${item} внутри массива ${arrTwo}`);
}); 

                                            // 3 - ДЕСТРУКТУРИЗАЦИЯ МАССИВА


// Так же как и объекты по сути
// learn.js

// у нас есть массив с именем и фамилией
let arrT = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arrT;

console.log(firstName); // Ilya
console.log(surname);  // Kantor

//                         4 - Псевдо массивы  - это сруктура которая просто хранит данные по порядку! Без всяких методов и преколов выше!

// когда будем получать элементы со страницы там дивы хуивы теги хуеги
// мы все будем получать в псевдо массивах! У них нету методов которые мы разбирали выще. КТо мы? я тут один ебобо
// В псевдо массивах есть свойство length

// ПРИМЕР: 

const bg1 = document.getElementsByTagName('button'); // получили все кнопки со страницы в виде псевдо массива  (об этом в файле 16)
// и нам нужно например обратиться к первому элементу, а там допустим всего один элемент и мы такие пишем
bg1.style.borderRadius = '100%'; // Почему будет ошибка? А потому что мы обращаемся к псевдомассиву, он ничего не знает про объект style
// Поэтому нам нужно указать индекс даже если у нас всего один элемент 
bg1[0].style.borderRadius = '100%'; // вот теперь мы обратились к первому элементу у которого уже есть внутри объект style и тд
