[Немного терминологии](#termin)<br>
[Операторы присваивания]()<br>
[Операторы сравнения]()<br>
[Математические операторы]()<br>
[Логические операторы]()<br>
[Оператор объединения с null '??']()<br>

## <a name ='termin'> Термины </a> ##

#### Операнд или аргумент – то, к чему применяется оператор.
```javaScript
Console.log(2 * 3) // 2 и 3 - это операнды. 
```

#### Унарный(Унарная операция)  - так называется оператор, который применяется к одному операнду.
```javaScript
// Унарный минус. Сделали из положителного числа, отрицательное.
let x = 3;
console.log(-x) // - 3
```
#### Бинарный(Бинарная операция) - Бинарным называется оператор, который применяется к двум операндам.

```JavaScript
// обычное прибавление например.
let y = 2;
let x = 1;

console.log( y + x) // 3
```
## Операторы присваивания ##
Оператор присваивания выглядит как равно '='.
```javaScript
let j = 1; // присвоили переменной j единицу!
console.log(j) // 1
```
Есть такая вещь как ассоциативность - она определяет порядк выполнения операторов с одинаковым приоритетом.
У оператора присваивания правая ассоциативность, что значит работать они будут справа налево. У разных операторов своя ассоциативность и свой приоритет выполнения, знать наизусть все не нужно, вся документация есть в интернете.
```javaScript
let k;
let h;
let b = 20;

let sum = k = h = b; // сначала мы в h присвоили b(20), далее в k присвоили h(20) и так по цепи.
console.log(sum); // поэтому в коносль выведет 20
```
Так же можно создавать переменные через запятую. Написали ключевое слово и через запятую пишем переменные.
```javaScript
let k,h,b,sum;
// тут более понятная запись присваивания по цепи.
b = 20;
h = b;
k = h;
sum = k;
console.log(sum); // 20
```
### Составные операторы присваивания ###
В javaScript есть составные операторы присваивания. Самые популярные: +=, -=, *=, /=, и тд.
Эти операторы перед присваиванием выполняют еще другую операцию.<br>
Например: '+=' - присваивание со сложением. Складывает(прибавляет), а потом присваивает. Это нужно для сокращения подобной записи:
```javaScript
let a = 11;
let b = 10;

b = a + b; // здесь можно так же заметить приоритетность, сначала мы прибавляем, а потом присваиваем. плюс имеет больший приоритет чем присваивание.
console.log(b) // 21
// Теперь используем оператор +=
b += a;
console.log(b) // 21
```
Как же я ЛЮБЛЮ ОПЕРАТОРЫ вот они слева направо:
- Присваивание с вычитанием  -=
- Присваивание с умножением  *= 
- Присваивание с делением   /=
- Присваивание с делением с остатком %=<br>

Все остальные операторы можно посмотреть в документации вместе с приоритетностью и ассоциативностью на MDN.  Принцип у них у всех одинаковый, просто сокращенная форма присваивания с другими операторами.

      

## Операторы сравнения ##
Операторы сравнения сравнивают два операнда и возвращают булевое значение.
Если сравнение правдивое, то будет true в остальных случаях false.
### Оператор равенства и строгое равенство ###
Оператор равенста выглядит как  два равно '=='
```javaScript
console.log(2 * 5 == 10) // true
// приоритет умножения больше чем у равенства, поэтому сначала мы умножили и получилось 10, а потом мы сравниваем 10 с 10, и получаем true так как 10 это 10.
```
При сравнении значений разных типов JavaScript приводит каждое из них к числу.<br> Если это булевые значения то true будет 1, а false - 0
```javaScript
console.log(2 * 5 == '10') //  true
console.log(true == 1); // true
console.log(false == 0); // true
```
Строгое равенство выглядит как три равно '===' и сравнивает не только значение как '==', но и тип данных. Он сравнивает без приведения типов.
```javaScript
console.log(2 * 5 === '10'); // false
console.log(false === 0) // false
```

### Оператор не равенства (Не равно) и строгое не равно ###
Оператор выглядит как '!=' и делает обратное равенству.
```javaScript
console.log(2 * 5 != 10); // false
// мы как бы спрашиваем 10 и 10 не равно друг другу, но они равны, поэтому мы получаем false
```
И так же строгое не равно '!=='
```javaScript
console.log(2 * 5 !== '10'); // true
// 10 не равно '10' - это правда поэтому получаем true
```
### Операторы Больше, меньше, больше или равно, меньше или равно ###
// 5) Больше >
// Возвращает true, если операнд слева больше операнда справа.
console.log(2 > 1); // true
// 6) Больше или равно >=
// Возвращает true, если операнд слева больше или равен операнду справа.
console.log(2 >= 1); // true (2 больше одного!)
console.log(2 >= 2); // true (2 равно 2!)
// 7) Меньше <
// Возвращает true, если операнд слева меньше операнда справа.
console.log(1 < 2); // true (1 меньше 2)
console.log(1 < 0); // false ( 1 не меньше 0)
// 8) Меньше или равно <=
// Возвращает true, если операнд слева меньше или равен операнду справа
console.log(1 <= 1); // true (1 равен 1)
console.log(10 <= 2); // false (2 меньше 10)

//                                                  3 - Математические операторы 
/* 1) ВЗЯТИЕ ОСТАТКА % 

оставялет остаток после деления.
например моя супер функция минуты в часы:
function getHours (allSum) {
let minutes = allSum % 60;
let hours = (allSum - minutes) / 60 + `:${minutes}`;
return hours;

мы при вызове функции указываем минуты, которые деляетс на 60 с остатком, так как в часу 60 минут)
после деления остается остаток например: 30 % 60 (какой остаток? а никакого, поэтому нам просто выведет 30)
а если 61 % 60 с остатком? остаток 1, очевидно, да? по сути наше первое число нужно уместить в 60 ящиках(представим это так)
60 % 60 все очень просто у нас 60 пуписичек и 60 ящиков, остатка нет) но тут бах не 60, а 61 и все 1 лишний - это и есть остаток
68 % на 60 Даст остаток 8
80 % на 60 даст остаток 20 ( что в моей функции дает нам 1 час и 20 минут)
до сих пор не понимаю, почему в калькух в гугле, просто делят на 60. ужас конечно
и так деланее пока мы не придем к 120, что опять дает 0 а 119 дает нам наши 1 час и 59 минут
а возьме 50, То все у нас 50 ящиков, те же 80 % 50 давать теперь будет 30
по сути мы начиная от 50 и до опять 50 то есть уже 100 потмо 150 и тд(мы по ступенькам как бы идем) 50 и 50 дают 0 остатка 51 и 50 уже 1 и так до 100, пока мы не пройдет эти 50 ступеней
52 и 50  дадут 2 остаток и тд( на всякий объясняю прям супер просто)

если по математике, то все деление просто пытается все четко уместить 153(делитель) / 50(делимое) будет 3,06(частное) ( деление просто пытается все уместить в 50 ящиков
что в сумме выходит 3 ящика это наше 50 + 50 + 50(150) а 3 тоже пытается разбить по всем ящикам и выходит 3 / 50 = 0,06 в сумме всех чисел = 3,06  
Наше деление просто раскинуло все по ящикам а остаток в 3 разделила так, что бы они тоже там уместились.
а оператор % просто нам показывает остаток, без дальнейшего развития и не пытается ничего уместить. в отличии от обычного деления которе наш остаток в 3, тоже пытается разделить по ящикам
153 % 50 = просто даст 3 и все  - это то, что не уместилось в ящиках. 
так как говорим только о остатках остальную часть функции не вижу смысла объяснять, к тому же это увижу только я сам, капец
зачем я все это пишу?





                2) Возведение в степень **
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.

Например:

alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)


            3) Сложение строк при помощи бинарного +


Обычно при помощи плюса '+' складывают числа.

Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
let s = "моя" + "строка";
alert(s); // моястрока

alert (2 + '2'); если есть хотя бы один операнд, то второе автомаом переведет тоже в число.  (тут двойка строка)
выведет: 4

            4) Унарный плюс и минус

Преобразует не числа в числа

console.log(5 + +'5') = 10
console.log(+""); = 0
console.log(+true); = 1

    вот так работаем со строками

let apples = "2";
let oranges = "3";

оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

Унарный минус:
Если z равно 3, тогда -z вернёт -3.
*/
let z = 3;
console.log(-z); // -3



//  5) ИНКРЕМЕНТ - ДЕКРЕМЕНТ
//                     

let incr = 10,
    decr = 10;

//постфиксная форма:

//    incr++; // прибавил 1
//    decr--; // отнял 1

// Префиксная форма:

//    ++incr; // прибавил 1
//    --decr; // отнял 1


// РАзница между ними!

console.log(incr++); // будет 10.  постфиксная форма, сначала возвращает старое значение
console.log(decr--); // Будет 10 если делать сразу как здесь в логе, то везде еще будет по 10
// но если начать ими сейчас пользоваться, То значения уже будут изменены, как пример ниже
console.log(++incr); // 12.  Префексная форма сразу нам возвращает значение!
console.log(--decr); // 8. но если тут ее изменить на постфиксную форму, то будет 11 и 9 и тд
//                      оно работает с числом как нужно , но сначала возвращает старое число, а после уже новое!

/*
Инкремент/декремент можно применить только к переменной.
Попытка использовать его на значении, типа 5++, приведёт к ошибке. */





//                              4 - Логические Операторы  && и || (и - или)

// 1) && - И

const isCheck = true,
    isClose = true;
console.log(isCheck && isClose); // выдаст true!
// если хотя бы одно значение будет false, то мы будем получать всегда false
// по сути это звучит так 'если и там и там true то мы делаем что то!'
// Логическое и! и то и то должно быть верным 

//  у && есть небольшое правило связанное с возвратом значения
console.log(2 && 1 && null && 0 && undefined); // null
// оператор слева на право проверяет 2 - дает true 1 - тоже ture
// далее null - false. Оператор запинается на первом false  и его взвращает

// 2) || - или 

const isOpen = true,
    isclosed = false;
console.log(isOpen || isclosed);
// тут если хотя бы одно есть true то будет выдавать true
// мы как бы говорим: есть хотя бы ЭТО или ЭТО и если есть одно из них, мы получаем true!
// Все логично

// тут тоже правило что и с && только запинается на первом true
console.log(0 || 3 || 0); // 3



// совсем для маленьких:
и
// пися && пися = это два одинаковых слова? (да)
и
// пися && ПупаЛупа = это два одинаковых слова? (нет)
или
// пися || Пупалупа - что то из них является - 'пися' (да)
или
// пИпа || Пупалупа - что то из них является - 'пися' (нет)

// в примерах везде два аргумента,но можно их делать сколько душе угодно (пися && пися && пися && пися)



// 3) НЕ ! - меняет true на false и на оборот 
console.log(2 + 2 != 4); // false
console.log(2 + 3 != 4); // true




//                                                          5 - ТЕРНАРНЫЙ оператор ? :
// тернарный потому что -  в нем участвует 3 аргумента
// единственный тернарный оператор в js
const numb = 50;

//  1 аргумент    2 аргумент       3 аргумент
(numb === 50) ? console.log('ok') : console.log('er');
// проверяет равно ли num 50, и если да, то выполянет, то, что после ?
// иначе, то, что после :



//                                                          6 - Оператор объединения с null ?? (спасиба js learn)
// Оператор объединения с null представляет собой два вопросительных знака ??

/*
Результат выражения a ?? b будет следующим:

a, если значение a определено,
b, если значение a не определено.
*/
//То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
//Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:

result = (a !== null && a !== undefined) ? a : b;

// Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

// Например, в следующем примере, если переменная user не определена, покажем модальное окно с надписью Аноним:

let user;

alert(user ?? "Аноним"); // выведет  аноним


let user = 'не педик';

alert(user ?? "я педик"); // а тут уже выведет не педик, потому что user определена 

// Разница между  ?? и ||

/*
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined.
Для него они все одинаковые, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений,
то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда,
когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определен
*/

let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0

/*
Если нулевая высота является «нормальным» значением,
которое не должно заменяться значением по умолчанию, 
то оператор ?? делает как раз то, что нужно.
*/

/*
Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

Запрещено использовать вместе с || или && без явно указанных круглых скобок.
*/

let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
