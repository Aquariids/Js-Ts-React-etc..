[Немного терминологии](#termin)<br>
[Операторы присваивания]()<br>
[Операторы сравнения](#comparison)<br>
[Математические операторы](#matOperator)<br>
[Логические операторы]()<br>
[Оператор объединения с null '??']()<br>

## <a name ='termin'> Термины </a> ##

#### Операнд или аргумент – то, к чему применяется оператор.
```javaScript
console.log(2 * 3) // 2 и 3 - это операнды. 
```

#### Унарный(Унарная операция)  - так называется оператор, который применяется к одному операнду.
```javaScript
// Унарный минус. Сделали из положителного числа, отрицательное.
let x = 3;
console.log(-x) // - 3
```
#### Бинарный(Бинарная операция) - Бинарным называется оператор, который применяется к двум операндам.

```JavaScript
// обычное прибавление например.
let y = 2;
let x = 1;

console.log( y + x) // 3
```
## <a name ='#'> Операторы присваивания </a> ##
Оператор присваивания выглядит как равно '='.
```javaScript
let j = 1; // присвоили переменной j единицу!
console.log(j) // 1
```
Есть такая вещь как ассоциативность - она определяет порядк выполнения операторов с одинаковым приоритетом.
У оператора присваивания правая ассоциативность, что значит работать они будут справа налево. У разных операторов своя ассоциативность и свой приоритет выполнения, знать наизусть все не нужно, вся документация есть в интернете.
```javaScript
let k;
let h;
let b = 20;

let sum = k = h = b; // сначала мы в h присвоили b(20), далее в k присвоили h(20) и так по цепи.
console.log(sum); // поэтому в коносль выведет 20
```
Так же можно создавать переменные через запятую. Написали ключевое слово и через запятую пишем переменные.
```javaScript
let k,h,b,sum;
// тут более понятная запись присваивания по цепи.
b = 20;
h = b;
k = h;
sum = k;
console.log(sum); // 20
```
### Составные операторы присваивания ###
В javaScript есть составные операторы присваивания. Самые популярные: +=, -=, *=, /=, и тд.
Эти операторы перед присваиванием выполняют еще другую операцию.<br>
Например: '+=' - присваивание со сложением. Складывает(прибавляет), а потом присваивает. Это нужно для сокращения подобной записи:
```javaScript
let a = 11;
let b = 10;

b = a + b; // здесь можно так же заметить приоритетность, сначала мы прибавляем, а потом присваиваем. плюс имеет больший приоритет чем присваивание.
console.log(b) // 21
// Теперь используем оператор +=
b += a;
console.log(b) // 21
```
Как же я ЛЮБЛЮ ОПЕРАТОРЫ вот они слева направо:
- Присваивание с вычитанием  -=
- Присваивание с умножением  *= 
- Присваивание с делением   /=
- Присваивание с делением с остатком %=<br>

Все остальные операторы можно посмотреть в документации вместе с приоритетностью и ассоциативностью на MDN.  Принцип у них у всех одинаковый, просто сокращенная форма присваивания с другими операторами.

      

## <a name ='comparison'> Операторы сравнения </a> ##
Операторы сравнения сравнивают два операнда и возвращают булевое значение.
Если сравнение правдивое, то будет true в остальных случаях false.
### Оператор равенства и строгое равенство ###
Оператор равенста выглядит как  два равно '=='
```javaScript
console.log(2 * 5 == 10) // true
// приоритет умножения больше чем у равенства, поэтому сначала мы умножили и получилось 10, а потом мы сравниваем 10 с 10, и получаем true так как 10 это 10.
```
При сравнении значений разных типов JavaScript приводит каждое из них к числу.<br> Если это булевые значения то true будет 1, а false - 0
```javaScript
console.log(2 * 5 == '10') //  true
console.log(true == 1); // true
console.log(false == 0); // true
```
Строгое равенство выглядит как три равно '===' и сравнивает не только значение как '==', но и тип данных. Он сравнивает без приведения типов.
```javaScript
console.log(2 * 5 === '10'); // false
console.log(false === 0) // false
```

### Оператор не равенства и строгое не равенство ###
Оператор не равенства записывается как '!=' и делает обратное равенству. 
```javaScript
console.log(2 * 5 != 10); // false
// мы как бы спрашиваем 10 и 10 не равно друг другу? нет, они равны, поэтому мы получаем false. 
// при равенстве мы спрашиваем равны ли они, а здесь все наоборот, поэтому где при равентсве true, при не равенстве всегда будет false.
```
И так же строгое не равно '!=='
```javaScript
console.log(2 * 5 !== '10'); // true
// 10 не равно '10' - это правда поэтому получаем true
```
### Операторы (больше) и (меньше) и операторы (больше или равно) и (меньше или равно) ###
Оператор больше '>' - возвращает true, если операнд слева больше операнда справа.
```javaScript
console.log(2 > 1); // true
console.log(1 > 2) // false
// два больше чем один? Да, поэтому получаем true и наоборот
```
Оператор меньше '<' - возвращает true, если операнд слева меньше операнда справа.
```javaScript
console.log(1 < 2); // true (1 меньше 2)
console.log(1 < 0); // false ( 1 не меньше 0)
```
Оператор больше или равно '>=' - возвращает true, если операнд слева больше или равен операнду справа.
```javaScript
console.log(2 >= 1); // true (2 больше 1)
console.log(2 >= 2); // true (2 равно 2)
```
Оператор меньше или равно '<=' - возвращает true, если операнд слева меньше или равен операнду справа
```javaScript
console.log(1 <= 1); // true (1 равен 1)
console.log(20 <= 2); // false (20 больше 2)
```
## <a name ='matOperator'> Математические операторы </a> ##
Оператор взятия остатка '%' - оставляет остаток после деления.
```javaScript
console.log(30 % 60); // остаток 0
```
Немного деления для маленьких(это я про себя).<br>
Когда мы делим у нас есть делитель, делимое и частное.
```javaScript
console.log(154 / 50); // 154 - это делитель, 50 - это делимое, а то, что получится - 3.08 частное.
```
Обычное деление разбивает и делит все. 150 / 3 дают нам 3 целых, а остаток в 4 тоже делит, что дает нам 8 сотых в итоге - 3.08.
Так вот взятие остатка, как раз этот остаток в 4 не делит, а возвращает нам.
```javaScript
console.log(154 % 50); // 4
// и остаток у нас так и будет приходить, пока мы не дойдем до 200,250,300 и так далее.
// Мы делим 199 / 50. 150 делится ровно на 3, а 49 нет, поэтому этот остаток нам возвращают.
// И тд...
console.log(199 % 50); // 49
console.log(200 % 50); // 0
console.log(201 % 50); // 1
console.log(202 % 50); // 2
```
Возведение в степень ' ** '<br>
В выражении a ** b оператор возведения в степень, умножается на само себя b раз.
Например:
```javaScrript
alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)
```
Сложение строк при помощи бинарного +.<br>
Обычно при помощи плюса '+' складывают числа.
Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
```javaScript
let s = "моя" + "строка";
alert(s); // моястрока
```
Унарный плюс и минус<br>

Преобразует не числа в числа

console.log(5 + +'5') = 10
console.log(+""); = 0
console.log(+true); = 1

    вот так работаем со строками

let apples = "2";
let oranges = "3";

оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

Унарный минус:
Если z равно 3, тогда -z вернёт -3.
*/
let z = 3;
console.log(-z); // -3



//  5) ИНКРЕМЕНТ - ДЕКРЕМЕНТ
//                     

let incr = 10,
    decr = 10;

//постфиксная форма:

//    incr++; // прибавил 1
//    decr--; // отнял 1

// Префиксная форма:

//    ++incr; // прибавил 1
//    --decr; // отнял 1


// РАзница между ними!

console.log(incr++); // будет 10.  постфиксная форма, сначала возвращает старое значение
console.log(decr--); // Будет 10 если делать сразу как здесь в логе, то везде еще будет по 10
// но если начать ими сейчас пользоваться, То значения уже будут изменены, как пример ниже
console.log(++incr); // 12.  Префексная форма сразу нам возвращает значение!
console.log(--decr); // 8. но если тут ее изменить на постфиксную форму, то будет 11 и 9 и тд
//                      оно работает с числом как нужно , но сначала возвращает старое число, а после уже новое!

/*
Инкремент/декремент можно применить только к переменной.
Попытка использовать его на значении, типа 5++, приведёт к ошибке. */





//                              4 - Логические Операторы  && и || (и - или)

// 1) && - И

const isCheck = true,
    isClose = true;
console.log(isCheck && isClose); // выдаст true!
// если хотя бы одно значение будет false, то мы будем получать всегда false
// по сути это звучит так 'если и там и там true то мы делаем что то!'
// Логическое и! и то и то должно быть верным 

//  у && есть небольшое правило связанное с возвратом значения
console.log(2 && 1 && null && 0 && undefined); // null
// оператор слева на право проверяет 2 - дает true 1 - тоже ture
// далее null - false. Оператор запинается на первом false  и его взвращает

// 2) || - или 

const isOpen = true,
    isclosed = false;
console.log(isOpen || isclosed);
// тут если хотя бы одно есть true то будет выдавать true
// мы как бы говорим: есть хотя бы ЭТО или ЭТО и если есть одно из них, мы получаем true!
// Все логично

// тут тоже правило что и с && только запинается на первом true
console.log(0 || 3 || 0); // 3



// совсем для маленьких:
и
// пися && пися = это два одинаковых слова? (да)
и
// пися && ПупаЛупа = это два одинаковых слова? (нет)
или
// пися || Пупалупа - что то из них является - 'пися' (да)
или
// пИпа || Пупалупа - что то из них является - 'пися' (нет)

// в примерах везде два аргумента,но можно их делать сколько душе угодно (пися && пися && пися && пися)



// 3) НЕ ! - меняет true на false и на оборот 
console.log(2 + 2 != 4); // false
console.log(2 + 3 != 4); // true




//                                                          5 - ТЕРНАРНЫЙ оператор ? :
// тернарный потому что -  в нем участвует 3 аргумента
// единственный тернарный оператор в js
const numb = 50;

//  1 аргумент    2 аргумент       3 аргумент
(numb === 50) ? console.log('ok') : console.log('er');
// проверяет равно ли num 50, и если да, то выполянет, то, что после ?
// иначе, то, что после :



//                                                          6 - Оператор объединения с null ?? (спасиба js learn)
// Оператор объединения с null представляет собой два вопросительных знака ??

/*
Результат выражения a ?? b будет следующим:

a, если значение a определено,
b, если значение a не определено.
*/
//То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
//Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:

result = (a !== null && a !== undefined) ? a : b;

// Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

// Например, в следующем примере, если переменная user не определена, покажем модальное окно с надписью Аноним:

let user;

alert(user ?? "Аноним"); // выведет  аноним


let user = 'не педик';

alert(user ?? "я педик"); // а тут уже выведет не педик, потому что user определена 

// Разница между  ?? и ||

/*
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined.
Для него они все одинаковые, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений,
то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда,
когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определен
*/

let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0

/*
Если нулевая высота является «нормальным» значением,
которое не должно заменяться значением по умолчанию, 
то оператор ?? делает как раз то, что нужно.
*/

/*
Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

Запрещено использовать вместе с || или && без явно указанных круглых скобок.
*/

let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
