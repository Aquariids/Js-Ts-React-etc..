[Немного про ООП]()<br>
[Прототипное наследование]()<br>

## Поговорим про ООП
ООП - Парадигма прогроммирования - Объектно-Ориентированное Программирование.(ООП - это наука о том как делать правильную архитектуру)<br>
Парадигма программирования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию).
Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером. Разные языки используют разные принципы внутри себя.
Спасибо википедия!
Так вот javaScript - Объектно-Ориентированный язык и главную роль в нем играет объект.
Этот объект внутри себя может содержать методы, свойства, любой тип данных и представлять собой целостную сущность
### Типичные пример с авто
Представим себе легковую машину как объект - у него есть такие свойства как двигатель, кузов, колёса и тд.
Есть такие методы как езда, перевозка чего либо и тд. Все то, что авто умеет делать и эти методы у всех легковых авто одинаковы.
Смысл объектно-Ориентированного программирования в том, что мы представляем любую вещь как объект с набором свойств, методов.
Точно также мы можем представить и холодильник и микроволновку и так далее.
### Как работают примитивы в js
Вот обычная строка 'люблю аниме' - это примитив.
Но как только мы применяем какой то метод, то javaScript оборачивает эту строку в объект и после модификации возвращает строку на место.
```javaScript
let str = 'Люблю аниме';
let strObj = new String (str);

console.log(typeof(str)); // string
console.log(typeof(strObj)); // object
// Тоже самое будет и с nubmer.
```
Такая вот работа методов в JavaScript.
Js просто оборачивает строку в объект, потом использует какой-то метод который есть у этого объекта, а потом возвращает все обратно.
## Прототипное наследование
Когда мы что-то создаем, мы создаем просто экземпляр прототипа
```javaScript
console.dir([1,2,3]); // в консоли браузера мы увидим __proto__:Array(0)
// если мы откроем эту вкладку, то увидим все методы которые могут применяться к массивам.
// Там же можно посмотреть прототип прототипа массива и это будет объект, все приходит к объекту
```
### Создаем солдата
```javaScript


```
const soldier = {   // создаем объект и описываем его
    health:400,   // у нашего солдата будет 400хп
    armor:100,    // и 100 брони
    sayHello: function () {
        console.log('hello');
    }

    // это по сути наш прототип, от него будет создавать экземпляры
};

const jonh = {     // наш экземпляр, у него те же свойства, но некоторые отличаются в виду его особеностей
    health: 100 // хп у него чутка меньше
};

// теперь связываем его с нашим прототипом
                    // ЭТО УСТАРЕВШИЙ СПОСОБ!!!!

/*jonh.__proto__ = soldier;

console.log(jonh); // { health: 100 } В консоли показывает только его здоровье
// но если я сейчас оращусь к свойству armor через jhon

console.log(jonh.armor); // 100

//  У самого объекта только одно свойство, но благодаря тому, что мы указали прототип он так же получил и свойства прототипа!
// все это касается и методов
jonh.sayHello(); */


                                    // СОВРЕМЕННЫЙ СПОСОБ Object.setPrototypeOf()  и  Object.create();

Object.setPrototypeOf(jonh,  soldier); // Первый аргумент - это тот кому мы назначаем прототип
                                    // Второй - это сам прототип
jonh.sayHello();

// Это все работа в динамике джон существовал и мы ему установили какой-то прототип
// но обычно это все происходит на этапе создания объекта


const jack = Object.create(soldier); // мы создаем объект jack и сразу назначили ему прототип!

jack.sayHello();

jack.health = 150;  // Все и дальше можем спокойно с ним работать

console.log(jack); //{ health: 150 }
console.log(jonh); // { health: 100 }
// два бравых солдата с разным хп, но одинаковой броней из за их общего прототипа
