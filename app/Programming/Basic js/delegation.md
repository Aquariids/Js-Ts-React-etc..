


//                                                        3 - Делегирование - работаем с родителем который дает права детишкам) так сказать


const section = document.querySelector('.section-two'),
// мы назначаем обработчик события на родителя, Далее пишем условие в котором проверяем наше событие на опр дочерний элемент
// и выполняем код только тогда когда нажали на нужныйы элемент внутри родителя

section.addEventListener('click', (e) => {

    // напоминаю, что через console.dir(e.target) мы можем получить элемент в виде объекта и посмотреть всю инфу этого элемента
    // оттуда у button мы получаем tagName:"BUTTON" - его мы будем использовать в нашем условии
    if (e.target && e.target.tagName == "BUTTON") { // пишем  e.target вначале для того что бы проверить его на существование. Не у всех тегов он есть
        // далее проверяем на имя тега 
        console.log('hello'); // при нажатии на любую кнопку внутри нашей секции мы будем получать hello
    }
});

// Так же можно проверять и на классы 
// (e.target && e.target.classList.contains('blue')) так мы проверяем на класс
// (e.target && e.target.matches("button.red")) - а эта штука проверяет на совпадение. рабоатем уже с селктором
// мы указываем тег и проверяем его на класс red
// в чем разница между делегированием и forEach пребором? 
// фишка в том, что forEach будет юзаться на всех кнопках из верстки, но когда мы будем уже после применения forEach сооздавать
// динамически доп кнопки, они не будут работать.
// ПРИМЕР:
btns.forEach(btn => {
    btn.addEventListener('click', () => {
        console.log('gello');
    });
});

const btnNew = document.createElement('button'); // Создаем нашу кнопку
btnNew.classList.add('red'); // Даем ей класс
section.append(btnNew); // помещаем на страницу

// на нашей btnNew не будет работать созданный выше forEach

