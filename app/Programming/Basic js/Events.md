[Обработчики событий]()<br>
[Объект event]()<br>
[Удаление обработчика событий]()<br>
[Всплытие событий]()<br>
[Отмена стандратного поведения браузера]()<br>
[]()<br>


## Обработчик события.
События - сигнал от браузера о том, что то произошло.
Всякие клики, двойной клик например, наведение мыши или убрать мышь с элемента и тд
Перед тем как использовать событие, мы должны назначить оброботчик события.
Обработчик события  - это функция которая срабатывает как только событие произошло

Есть 3 способа записать обработчик событий (Первые 2 устаревшие варианты)
#### 1) - Напрямую в html коде добавляем на элемент
```javaScript
// записываем тегу button событие click с приставкой on и в ковычках пишем js код.
<button onclick="console.log('я дима')" class="btn">я не дима </button>
// При нажатии на эту кнопку в консоль будет выводить текст - это и есть наш обработчик
```
#### 2) - Использовать свойства DOM дерева. 
```javaScript
// Сначала нам нужен элемент
const btn = document.querySelector('button');

btn.onclick = function () { // обращаемся к нашему элементу и в свойство onclick записываем функцию
    console.log('hello');
};

// Если у вас большой код и вы назначали обработчик, а потом забыли, что взаимодействовали с этим элементом и назначали обработчик еще раз:

btn.onclick = function () {
    console.log('hello world'); // - этот второй раз перезапишет первый обработчик и вы просто потеряете функционал
};
```
В реальном проекте вы можете забыть или даже не знать, что есть обработчик события. При этом иногда нужно обработчик удалить, с таким синаксисом это не получится. Поэтому сейчас используют немного другой способ<br>

#### 3) - Обработчик события addEventListener() - современный способ
У addEventListener 2 аргумента. 1 - событие(название события)  2 - колбек функция.  
```javaScript
const btn = document.querySelector('button');
btn.addEventListener('click', () => {  // 'click' - первый наш аргумент, событие клика мыши. 
    console.log('Hello Dima');
}); // В общем js следит за этим элементом btn.addEventListener и если произошло событие нами написанное
// то срабатывает колбек функция(как мы помним, колбек функции выполняются строго за другими) в нашем случае после события. 
// Если мы навесим еще один обработчик, то он не перезапишет предыдущий.
btn.addEventListener('click', () => {
    console.log('Hello SEREGA'); // Наше действие не перезапишет предыдущее, они сработают по порядку
});
// События в js выполняются в порядке очереди!
```
![hello serega and dima](https://github.com/Aquariids/MyJS/blob/main/app/img/%D0%91%D0%B5%D0%B7%D1%8B%D0%BC%D1%8F%D0%BD%D0%BD%D1%8B%D0%B9.png)<br>
## Объект event
Иногда нам нужно получать данные о том элементе с которым мы взаимодействуем, для этого у нас есть специальный объект event, этот объект передается как аргумент в колбек функцию (называть можем как угодно, но обычно это event или e).
```javaScript
const btn = document.querySelector('button');
btn.addEventListener('click', (event) => {
    console.log(event); // и мы получим MouseEvent {isTrusted: true, screenX: 360, screenY: 697, clientX: 196, clientY: 511, …}
    // это объект который описывает, что произошло с элементом. Внутри очень много всего, но самые важные свойства это: 

        // type: "click" - это то какое событие у нас произошло в нашем случае это клик
        // target: button.btn - это тот элемент на котором произошло событие
    
    // Например можем удалить наш элемент.
    // мы обращаемся к к объекту event и к свойству target в котором помещается элемент с которым мы взаимодействуем.
    event.target.remove(); // при нажатии элемент удаляется.
});
```                                                       
## Удаляем обраотчик события removeEventListener() 
removeEventListener - удаляет обработчик события зарегистрированный ранее с помощью метода addEventListener().
```javaScript
let i = 0;
const btn = document.querySelector('button');

// Для того, что бы удалить обрабочик события, нам нужно ссылаться на одинаковые функции.
const showElement = (event) => { // Создаем нашу функцию в переменной.
    console.log(event.target); // выводим в консоль наш элемент.
    i++
    if (i == 1) { // пишем условие, что если i равна 1 
        btn.removeEventListener('click', showElement); // то мы удаляем наш обработчик события(ссылаемся на одну функцию)
    }
};
btn.addEventListener('click', showElement); // Передаем в обработчик ссылку на функцию вторым аргументом.
// При нажатии на кнопку наша кнопка выведется в консоли, i станет равна 1 и удалит обработчик, последующие нажатия уже не дадут никакого результата.
// если бы я написал внутри каждого обработчика одинаковые функции они бы не были равны, это все равно было бы два разных объекта, поэтому просто ссылаемся на одну функцию!
```
 ## Всплытие событий
Всплытие событий - это когда обработчик события сначала срабатывает на самом вложенном элементе, затем на родителе если он есть и так выше и выше по иерархии
```javaScript

```
const section = document.querySelector('.section'); // родитель и ребенок делают одно и тоже событие 
section.addEventListener('click', deleteElement);

// вывод будет таков
/* <button class="btn">я гей просто</button>
<button class="btn">я гей просто</button>
но если мы выведем не target, currentTarget
тогда мы получим нашу кнопку <button class="btn">я гей просто</button>
и после всего родителя, в нашем случае section
<section class="section">
        <div class="bg" id="bg-id"><button class="btn">я гей просто</button></div>
        <div class="bg"><button class="btn">я гей первый</button></div>
        <div class="bg"><button class="btn">я гей второй</button></div>
        <div class="bg"><button class="btn">я гей третий</button></div>
    </section> вот так вот (html код в будщем может измениться, пока что section Выглядит так)

    1) currentTarget -  используется, когда один и тот же обработчик события присваивается нескольким элементам ( target юзает сам элемент,
        а currentTarget - его родителя)
*/

/*
 *                                                       1.4 - Отмена стандартного поведения браузера
 */
// 1) preventDefault - это метод у объекта события, нашего event

const link = document.querySelector('a');

link.addEventListener('click', (event) => {
    // при нажатии ссылка перекинет на мой гит, но если мы у события используем метод
    event.preventDefault(); // теперь ссылка никуда нас не перекинет, мы отменили ее стандартное поведение
    let i = 0;
    i++; // дальше тут делаем, что хотим
    console.log(i);
});



/*
*                                                          1.5 - перебераем обработчики и вешем несколько одинаковых на элементы (forEach)
Получить все кнопки например через querySelectorAll('button') и потом повесить обработчик на это, не получится, так как метод query даст нам
псевдо массив, а у него нет метода addEventListener
 */
// Для этого нужно этот псевдо массив нужно перебрать и на каждый элемент повесить обработчик

const btns = document.querySelectorAll('button');

btns.forEach((btn) => { // используем на нашем псевдомассиве forEach, В первом аргументе как мы помним находится элемент который перебераем
    btn.addEventListener('click', (e) => { // далее на каждый перебераемый элемент мы вешаем обработчик событий
        console.log(e.target); // и все
    });
});


/*
 *                                                     2 - опции события
у addEventListener() - есть третий аргумент - это опции (Объект options, который определяет характеристики объекта, прослушивающего событие)\
Например
once: указывает, что обработчик должен быть вызван не более одного раза после добавления.
записывается так addEventListener('click', тут событие,{once:true});
 */
/*
 *                                                   3 - СОБЫТИЯ
 */

//1) click -  происходит, когда кликнули на элемент левой кнопкой мыши 
// (на устройствах с сенсорными экранами оно происходит при касании).
//2) mouseover / mouseout – когда мышь наводится на / покидает элемент.
//3) mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
//4) mousemove – при движении мыши.
//5) mouseenter - при наведении мыщи на элемент
//6) submit -  нужон для отправки формы

/*
 *                                                   3.1 - Отправка формы submit
 */


// Submit юзается с формой тег <form> </form>
// Например:

// небольшая тренировка по созданию элементов)))
const form = document.createElement('form'); // создал форму
form.classList.add('eventsForm'); // добавил форме класс
const input = document.createElement('input'); // создал окошко ввода
input.classList.add('eventsForm__input'); // добавил класс окну
const windowDiv = document.createElement('div'); // сделал див в котоый будуотправлть данных из инпута
windowDiv.classList.add('window'); // добавил диву класс
document.body.append(form); // поместил форму в конец бади
form.append(input); // поместил окошко ввода в конец формы
form[0].before(windowDiv); //  добавил наше окошко вывода внутрь формы перед первым элементом(инпут наш)
const inputValue = document.querySelector('.eventsForm__input'); // получил наш инпут для работы

function userSees(parent, text) { // создал функцию которая помещает текст из поля ввода в наш див внутри формы

    parent.textContent = `
    ${text}
  `;

}

form.addEventListener('submit', (e) => { // наш обработчик формы( срабатывает когда из инпута, что то отправляем. На автомате стоит на энтер, можно добавить кнопочку)  
    e.preventDefault(); // сбрасываем обновление страницы после отправки 

    let userEntered = inputValue.value; // переменная в которой хранится все, что ввели в поле
    userSees(windowDiv, userEntered); // юзаем нашу функцию которая помещает текст в ди( указываем родителя сам див и вторым аргументом, то что ввели)
    e.target.reset(); // сбрасываем текст после ввода в окне инпут
});
