[Что такое this?](#this)<br>
[this такой разный.. где какой контекст?]<br>
## <a name="this"> что такое this? </a>
this - это контекст и он бывает разный, при разных вызовах функции. То есть в разных условиях this может иметь разное значение.
Так же можно сказать, что this - это переменная которая ссылается на объект, а какой объект уже зависит от условий функциий.
Или this это переменная которая принимает в себя что-то в зависимости от контекста в котором она находится.
Ниже разберем при каких условиях контекст будет изменяться.

## <a name="context"> this такой разный.. </a>

### this в  Обычной функции 
внутри функции this = window, но если у вас стоит строгий режим(use strict) тогда = undefiend.
```javaScript
"use strict";
function showThis (){
    console.log(this); 
}

showThis(); // мы получим undefined
```
Без строго режима:
```javaScript
function showThis (){
    console.log(this); 
}

showThis(); // получим объект window
```
![window](https://github.com/Aquariids/MyJS/blob/main/app/img/windowThis.png)<br>
А что если внутри функции будет еще функция с this?
```javaScript
"use strict"

function showThis2(a, b) { // создаем функцию с 2 аргументами, 
    console.log(this); // undefined

    function sum() { // внутри еще одну функцию
        console.log(this); // здесь контекст вызова будет такой же либо window либо undefiend.
        // так не пишем! return this.a + this.b;  // Если мы хотим что бы функция работала, нужно сделать замыкание.
        return a + b; // просто убираем this. функция не находит переменные a и b здесь и ищет их в функции выше 
    }

    console.log(sum()); // undefined
}

showThis2(1, 2); // 3
```
В общем в обычной функции будет window либо undefined в зависимоси от режима. Даже если функция находится внутри другой функции!
###
*               2 - Контекст у методов объекта - сам объект
*/

const obj = {  // Объект 
    a:20,
    b:15,
    sum: function() { // внутри метод
        function what () {
            console.log(this); // будет undefiend. Потому что это функция внутри метода, а не сам метод объекта,
            // поэтому тут все так же как было выше
        }
        console.log(this); // контекст будет объектом в котором находится функция
        
    }
};

obj.sum();


/*
*   3 - this в конструкторах и классах - это новый экземпляр объекта
*/


function User (name,age) {  // третий способ с функцией конструктор
    this.name = name; // эти this обращаются к объекту которые мы будем создавать 
    this.age = age;  // Посути вместо this каждый раз подставляется новый экземпляр объекта
    this.human = true; 
    this.hello = function () {
        console.log('hello' + this.name); // здесь this так же ссылается на объект который мы создали и берет его свойство name  
    };
    

    
}

let ivan = new User ('ivan',24);   // this ссылается на этот экземпляр
let dima = new User('Dima', 30); // и теперь на этот. здесь при создании мы сразу передаем значения в наши свойства name и id

dima.hello(); // выдаст (helloDima)


/*
*               4 - Ручная привязка this: call, apply, bind
*/

function sayName(sername) {            // как подвязать этой функции контекст объекта us?
    
    console.log(this);
    console.log(this.name + sername);
    
}


const us = {
    name: 'diman'
};

// Для этого есть два метода и один который сам создает новую функцию

//1)  call()
// просто вызываем у функции метод
sayName.call(us, 'chern'); // здесь аргументы добавляем просто через запятую в ковычках
//2) apply()
// оба  метода делают одно и тоже, но у них разный синтаксис
sayName.apply(us, ['nechern']); // здесб все тоже самое только внутри массива

//3)  bind()

function count(num) {
    return this*num; //  здесь в this будет двойка, мы ее передали ниже
    
}

const double = count.bind(2); // здесь мы по сути поместли в count новую функцию
console.log(double(2));  // а num будет передаваться в double
// мы навсегда забиндили функцию! создали ей ручной контекст ввиде двойки и теперь просто вызываем нашу double и передам нужный аргумент 
console.log(double(10)); // 20



/*
*                           Немного рабоатем с this
*/

//1) Если обработчик с обычной функцией, то this как и event target будет сам элемент события 
const btnThis = document.querySelector('.btn-this');

btnThis.addEventListener('click', function () {
        this.style.backgroundColor = 'red'; // при нажатии перекрасим кнопку в красный, так как this -  элемент события
    // елси же на событии использовать стрелочную функцию, то this будет window или undefiend так как не имеет контекста
});

//2) стрелочные функции. У стрелочных функций нет своего контекста вызова, она будет его брать у родителя

const obj2 = { // наш объект
 num: 2,
 sayNumber : function () { // метод этого объекта
    const say  = () => {
        console.log(this);  // функция внутри метода
    };

    say();
 }

};

obj2.sayNumber(); // контекстом будет объект  {num: 2, sayNumber: ƒ}

// на строчке 46 уже говорилось об этом, Только там была обычная функция
// стрелочная функция без контекста, поэтому она ссылается на родителя sayNumber - метод в свою очередь ссылается на объект
// поэтому наша this внутри say ссылается на сам объект obj2



/*
*                           Сокращение функций
*/
// const double2 = (a) => {
//         return a * 2; 
// };

// стрелочная функция была придуманна, что бы укарачивать наш код
// если действие функции помещается в одну строку, то мы можем написать его без фигурных скобок

const double2 = a => a * 2; // return подставится автоматически если действие помещается в одну строчку
// так же если стрелочная функция принимает только один аргумент, то можно написать без круглых скобок

console.log(double2(4));
