
/*
*                                   1 - Замыкания
*/
function one () {   // ебашим функцию
    let a = 0;  // ее лексияеское оркужение

    return function () {    // ебашим анонимную функцию
      return  a += 1;
    };
}

let b = one(); // в переменную добавляем нашу функцию one
console.log(b()); // 1
console.log(b()); // 2
let c = one(); // ебюашим еще одну переменную и кидаем в нее нашу one
console.log(c()); // выдает 1,
console.log(b());  // выдаст 3
console.log(c()); // 2  ничего не переписав.
// счетчик такой)
// и только эта анонимная функция может использовать облость видимости функции one
// по сути внутрености one приватны и открыты только для нашей анонимной фушнкции

// тьы спросишь меня брат, а че так нельзя что ли?

function two () {

  let a = 0;

    a += 1;
    return a;
}


console.log(two()); // и тут брат будет 1
console.log(two()); // а тут брат Тоже будет 1)
// а прикол весь в том, что переменная внутри функции живет только во время ее вызова
// то есть при вызове мы каждый раз делаем нашу а
// если же мы ее вытащим наружу, то тогда ее можно переписать.
// такая пляска

// 

//                                  римеры с какого то сайта!
/*
Обратите внимание — когда функция выполняется,
 её контекст выполнения удаляется из стека, 
 но её лексическое окружение может или не может быть удалено из памяти, 
 в зависимости от того, ссылается ли на это лексическое окружение другое лексическое окружение.


 function person() {
  let name = 'Peter';
  
  return function displayName() {
    console.log(name);
  };
}
let peter = person();
peter(); // prints 'Peter'

Когда выполняется функция person,
 JavaScript создаёт новый контекст выполнения и лексическое окружение для функции.
  После того, как эта функция завершится, 
  она вернёт displayName функцию и назначится на переменную peter.

  Когда функция person завершится, её контекст выполнения выкинется из стека.
   Но её лексическое окружение всё ещё останется в памяти,
    так как на него ссылается лексическое окружение его внутренней функции displayName. 
    Таким образом, её переменные всё ещё будут доступны в памяти.
*/


/*
*                                            РЕКУРСИЯ
*/


// Рекурсия - это когда функция вызывает сама себя( типо цикл)
 // let t = 0; // глобальная переменная

 // function f1(){ // наша функция
    //  t++; // добавляем 1
     //  console.log(t); // выводим
      // если просто запустим функцию будет 1, но далее мы пишем
     // f1(); // мы запускаем  внутри функцию саму себя - это и есть рекурсия
//  }

 // f1();// мы запустим функцию, она найдет выше t прибавит 1, потом выведет и после опять запустит сама себя
  // опять прибавит 1 в t и тд тд, пока мы ее не остановим в IDE или не пропишем условие
  // В js есть стек - это такое место куда добовляется очередь на выполнение, функция не будет бесконечной потому что рано или поздно этот список закончится, стек переполняется и работа заканчивается

  /*
  *                     Стек вызовов в js, Eventloop, обратные вызоовы(колбек) 
  */

  // начнем с того, что js это однопоточный язык с единичным последовательным исполнением операций
  // один поток == одному стеку вызовов == одному выполнению какой то операции за раз
  // как я сказал выше js это однопоточный язык,  в каждый момент времени js может делать одну операцию
// Стек вызовов - это структура данных, вкоторая, говоря упрощенно, записывает сведения о месте в программе, где мы находимся
// Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся мы вытаскиваем из стека самый верхний элемент и оказываемя там, откуда вызывали эту функцию - Это - все что умеет стек
function muptiply(a, b) {                     
  return a * b;
}

function square(n) {
  return muptiply(n,n);
}

function printSquare(n) {
  let squared = square(n);
  console.log(squared);
}

printSquare(4);              
 
/*
Когда функция производит вложенный вызов, происходит следующее:

Выполнение текущей функции приостанавливается.
Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.
*/
// НАШ СТЕК
// 1 script() - первым в стеке будет наш основной файл
// 2 - далее в стеке будет наша функция   printSquare(4), с входными данными 4
// 3 - далее пойдет squared,  так как мы ее вызываем внутри printSquare(4), printSquare - приостанавливает свою работу. входные данные переходят в n
// 4 -  Внутри squared вложенный вызов muptiply в ней мы получаем наше return value 16 и возвращаемся на место вызова в squared 
// 5 - мы вернулись в squared в n находится 4, наше return value 16, функцию muptiply выполнили, поэтому squared, заканчивает свою рабоут и убирается из стека
// 6 - далее мы возвращаемся в функцию printSquare в место вызова let squared = square(n) и возобновляем работу printSquare, натыкаемся на console log и на этом конец, так как оно ничего не возвращает
// что происходит, в стек шаг за шагом добавляется функция, в каждой этой функции есть какой то возврат
// когда мы доходим до a * b в muptiply, мы получаем некое возвратное выражение (return statement) или return value какое то значение
// и далее мы возвращаемся из функции и убираем верхний элемент в стеке muptiply, далее square, далее  printSquare.
// при выходе мы возвращаемся в место вызова и возобновляем работу функции в которой был совершен вызов



/*
* Рекурсия и контекст стека
*/
//   function pow(x, n) {
//     if (n == 1) {
//       return x; 
//     } else {
//       return x * pow(x, n - 1);
//     }
//   }

//   alert( pow(2, 3) ); // 8


// тут будет наш стек: идем снизу вверх как стек
// return value уже 8 и мы натыкаемся на alert, тут нет возвращемого и стек прекращает работу и вывод 8
// далее идет pow(2, 3) и наше return value уже 4, опять return x * pow(x, n - 1);
//   return value == 2 у нас есть вовращаемое число и n не равно 1, выполняется return x * pow(x, n - 1);
// Возобновляется обработка вызова pow(2,2), имя результат pow (2,1) он может закончить свою работу
// далее мы выходим из стека и убираем верхний элемент это pow(2, 1).
//3 pow(2, 1) далее мы пришли к тому что в n == 1 это истинна и мы возвращаем в функцию pow(2) двойку return x;
//2 pow(2, 2) далее:так как n не равно 1 мы идем в else где x * на возвращаемое выражение нашей функции и n - 1, нашего возвращаемого числа еще нет, мы отнимаем 1 
//1 pow(2, 3) вызвали нашу функцию и она добавилась в стек первой! 


// идем далее к сложному
//            Рекурсивные обходы


// Представьте, у нас есть компания. Структура персонала может быть представлена как объект:

let company = {
sales: [{
  name: 'John',
  salary: 1000
}, {
  name: 'Alice',
  salary: 600
}],

development: {
  sites: [{
    name: 'Peter',
    salary: 2000
  }, {
    name: 'Alex',
    salary: 1800
  }],

  internals: [{
    name: 'Jack',
    salary: 1300
  }]
}
};

console.log(company);

/*
Другими словами, в компании есть отделы.

Отдел может состоять из массива работников. Например, в отделе sales работают 2 сотрудника: Джон и Алиса.

Или отдел может быть разделён на подотделы, например, отдел development состоит из подотделов: sites и internals. В каждом подотделе есть свой персонал.

Также возможно, что при росте подотдела он делится на подразделения (или команды).

Например, подотдел sites в будущем может быть разделён на команды siteA и siteB. И потенциально они могут быть разделены ещё. Этого нет на картинке, просто нужно иметь это в виду.

Теперь, допустим, нам нужна функция для получения суммы всех зарплат. Как мы можем это сделать?

Итеративный подход не прост, потому что структура довольно сложная. Первая идея заключается в том, чтобы сделать цикл for поверх объекта company с вложенным циклом над отделами 1-го уровня вложенности. Но затем нам нужно больше вложенных циклов для итераций над сотрудниками отделов второго уровня, таких как sites… А затем ещё один цикл по отделам 3-го уровня, которые могут появиться в будущем? Если мы поместим в код 3-4 вложенных цикла для обхода одного объекта, то это будет довольно некрасиво.

Давайте попробуем рекурсию.
*/

// !                                        Event loop - событийный цикл

/*


*/

