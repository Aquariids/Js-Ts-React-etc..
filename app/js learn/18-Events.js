// События - сигнал от браузера о том, что то произошло.
// Всякие клики, двойной клик например, наведение мыши или убрать мыш с элемента и тд

/*
*                                                              0 - Обработчик события  (Не юзабельные)
Перед тем как использовать событие, мы должны назначить оброботчик события
Обработчик события  - это функция которая срабатывает как только событие произошло

Есть 3 способа записать обработчик событий (НЕ ИСПОЛЬЗУЕТСЯ)
1) - напрямую в html коде добавляем на элемент
<button onclick="console.log('я гей')" class="btn">я гей первый</button>
записываем тегу button событие click с приставкой on и в ковычках пишем код
при нажатии на эту кнопку в консоль будет выводить текст - это и есть наш обработчик
 */
// 2) Использовать свойства DOM дерева. Сначала нам нужен элемент
const btn = document.querySelector('button');

btn.onclick = function () { // обращаемся к нашему элементу и в свойство onclick записываем функцию
    console.log('hello');
}; // но это тоже не используется, у него есть большая проблема
// Если у вас большой код вы назначали обработчик, а потом забыли, что взаимодействовали с этим элементом
// и вы назначали обработчик еще раз
btn.onclick = function () { // обращаемся к нашему элементу и в свойство onclick записываем функцию
    console.log('hello world'); // - этот второй раз перезапишет первый обработчик и вы просто потеряете функционал

};
// в реальном проекте вы можете забыть или даже не знать, что есть обработчик события. При этом иногда нужно обработчик удалить
// с таким синаксисом это не получится

/* 
 *                                                       1 - Обработчик события addEventListener()
 */

btn.addEventListener('click', () => { //  2 аргумента. 1 - событие(название события)  2 - колбек функция  
    // console.log('Hello Dima');
}); // В общем js следит за этим элементом btn.addEventListener и если произощло событие нами написанное
// то срабатывает колбек функция(как мы помним, колбек функции выполняются строго за другими) в нашем случае после события
// так же если мы сделаем так
btn.addEventListener('click', () => {
    // console.log('Hello SEREGA'); // Наше действие не перезапишет предыдущее, они сработают по порядку
}); // События в js выполняются в порядке очереди!

//2)
/*
 *                                                         1.1 - Event
 */
// Иногда нам нужно получать данные о том элементе с которым мы взаимодействуем, для этого у нас есть специальный объект event
// event - передается как аргумент в колбек функцию ( называть можем как угодно, но обычно это event или e)
btn.addEventListener('click', (event) => {
    console.log(event); // и мы получим MouseEvent {isTrusted: true, screenX: 360, screenY: 697, clientX: 196, clientY: 511, …}
    // это объект который писывает, что произошло с элементом
    // внутри очень много всего, но самые важные это 
    /* 
        type: "click" - это то какое событие у нас произошло в нашем случае это клик
        target: button.btn - это тот элемент на котором произошло событие
    например:
    
    */
    console.log(event.target); // сразу получаем наш элемент
    event.target.remove(); // при нажатии элемент удаляется

});
/*
 *                                                           1.2 - Ссылка на функцию и removeEventListener() 
 */
// removeEventListener - удаляет обработчик события зарегистрированный ранее с помощью метода addEventListener().
let i = 0;
// Для того, что бы удалить обрабочик события, нам нужно ссылаться на одинаковые функции поэтому мы 
const deleteElement1 = (event) => { // Создаем нашу функцию в переменной 
    event.target.remove();
};
//btn.addEventListener('click', deleteElement1); // и передаем в обработчик ссылку на нее вторым аргументом
//btn.removeEventListener('click',deleteElement1); // и удаляем обработчик( мы ссылаемя на одну функцию)
// если бы я просто написал внутри каждого обработчика одинаковые функции они бы не были равны, это все равно было бы два разных объекта
// поэтому просто ссылаемся на одну!
// Пример работы:

const deleteElement = (event) => { // наша функция          
    console.log(event.target); // выводим наш элемент в консоль при каждом нажатии
    i++; // прибавляем 1 в i
    if (i == 1) { // пишем условие, что если i равна 1 
        btn.removeEventListener('click', deleteElement); // то мы удаляем наш обработчик события
    }
};
btn.addEventListener('click', deleteElement);
// произойдет такая штука, что мы нажмем один раз и нам выведется наш элемент <button class="btn">я гей просто</button>
// В  i добавится единичка и сработает наше условие if в котором мы удаляем обработчик btn.addEventListener('click',deleteElement);
// и при следующих нажатиях уже ничего не будет происходить

/*
 *                                                       1.3 - Всплытие событий
 */
// Всплытие событий - это когда обработчик события сначала срабатывает на самом вложенном элементе, затем на родителе если он есть и так
// выше и выше по ирархии

const section = document.querySelector('.section'); // родитель и ребенок делают одно и тоже событие 
section.addEventListener('click', deleteElement);

// вывод будет таков
/* <button class="btn">я гей просто</button>
<button class="btn">я гей просто</button>
но если мы выведем не target, currentTarget
тогда мы получим нашу кнопку <button class="btn">я гей просто</button>
и после всего родителя, в нашем случае section
<section class="section">
        <div class="bg" id="bg-id"><button class="btn">я гей просто</button></div>
        <div class="bg"><button class="btn">я гей первый</button></div>
        <div class="bg"><button class="btn">я гей второй</button></div>
        <div class="bg"><button class="btn">я гей третий</button></div>
    </section> вот так вот (html код в будщем может измениться, пока что section Выглядит так)

    1) currentTarget -  используется, когда один и тот же обработчик события присваивается нескольким элементам ( target юзает сам элемент,
        а currentTarget - его родителя)
*/

/*
 *                                                       1.4 - Отмена стандартного поведения браузера
 */
// 1) preventDefault - это метод у объекта события, нашего event

const link = document.querySelector('a');

link.addEventListener('click', (event) => {
    // при нажатии ссылка перекинет на мой гит, но если мы у события используем метод
    event.preventDefault(); // теперь ссылка никуда нас не перекинет, мы отменили ее стандартное поведение
    let i = 0;
    i++; // дальше тут делаем, что хотим
    console.log(i);
});



/*
*                                                          1.5 - перебераем обработчики и вешем несколько одинаковых на элементы (forEach)
Получить все кнопки например через querySelectorAll('button') и потом повесить обработчик на это, не получится, так как метод query даст нам
псевдо массив, а у него нет метода addEventListener
 */
// Для этого нужно этот псевдо массив нужно перебрать и на каждый элемент повесить обработчик

const btns = document.querySelectorAll('button');

btns.forEach((btn) => { // используем на нашем псевдомассиве forEach, В первом аргументе как мы помним находится элемент который перебераем
    btn.addEventListener('click', (e) => {    // далее на каждый перебераемый элемент мы вешаем обработчик событий
        console.log(e.target); // и все
    });
});


/*
 *                                                     2 - опции события
у addEventListener() - есть третий аргумент - это опции (Объект options, который определяет характеристики объекта, прослушивающего событие)\
Например
once: указывает, что обработчик должен быть вызван не более одного раза после добавления.
записывается так addEventListener('click', тут событие,{once:true});
 */
/*
 *                                                   3 - НАЗВАНИЯ СОБЫТИЙ
 */

//1) click -  происходит, когда кликнули на элемент левой кнопкой мыши 
// (на устройствах с сенсорными экранами оно происходит при касании).
//2) mouseover / mouseout – когда мышь наводится на / покидает элемент.
//3) mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
//4) mousemove – при движении мыши.
//5) mouseenter - при наведении мыщи на элемент