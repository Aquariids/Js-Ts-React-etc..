// НУ ДАВАЙ ЕБАНОЕ ООП, ПОСМОТРИМ КТО КОГО (ООП - это наука о том как делать правильную архитектуру)
// ООП - Парадигма прогроммирования - Объектно-Ориентированное Программирование)
/*
Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию).
Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.

Спасибо википедия

Так же здесь будет и об прототипно-ориентированном наследовании
РАЗНЫЕ ЗЛЫЕ (шутка, не злые) ЯЗЫКИ ИСПОЛЬЗЮТ РАЗНЫЕ ПРИНЦИПЫ ВНУТРИ СЕБЯ

Так вот js - Объектно-Ориентированный язые и главную роль в нем играет объект
Этот объект внутри себя может содержать методы, свойства, любой тип данных и представлять собой целостную сущность

*/


                                // теперь очередные тупые примеры (АВТО)

// представим ебаную ладу гранту как объект - у него есть такие свойства как Двигатель, кузов,колёса и тд
//  есть такие методы как езда, перевозка людей, грузов и тд всякое, что он умеет делать и у всех легковых авто так!

// смысл объектно-Ориентированного программирования в том, что мы представляем любую вещь как объект с набором свойств, методов
// точно также мы можем представить и холодильник и микроволновку и тд



// Короче вот обычная строка 'люблю аниме' - это ссаный примитив
// но как только мы применяем какой то метод, то js оборачивает эту строку в объект и после модицикации возвращает строку на место
// ПРИМЕР:

let str = 'Люблю аниме'; 
let strObj =  new String (str);

console.log(typeof(str)); // string
console.log(typeof(strObj)); // object

// Такая вот работа методов в Js
// Js просто оборачивает строку в объект, потом использует какой-то метод который есть у этого объекта, а потом возвращает все обратно
                                // ПРОТОТИПЫ

/* 
Посути когда мы что-то создаем, мы создаем просто экземпляр прототипа
*/

console.dir([1,2,3]); // в консоли браузера мы увидим __proto__:Array(0) - вот если мы ее откроем, то увидим все методы
// которые могут применяться к массивам. Там же можно посмотреть прототип прототипа массива и это будет объект, все приходит к объекту



//                                          СОЗДАЕМ СОЛДАТА

const soldier = {   // создаем объект и описываем его
    health:400,   // у нашего солдата будет 400хп
    armor:100,    // и 100 брони
    sayHello: function () {
        console.log('hello');
    }

    // это по сути наш прототип, от него будет создавать экземпляры
};

const jonh = {     // наш экземпляр, у него те же свойства, но некоторые отличаются в виду его особеностей
    health: 100 // хп у него чутка меньше
};

// теперь связываем его с нашим прототипом
                    // ЭТО УСТАРЕВШИЙ СПОСОБ!!!!

/*jonh.__proto__ = soldier;

console.log(jonh); // { health: 100 } В консоли показывает только его здоровье
// но если я сейчас оращусь к свойству armor через jhon

console.log(jonh.armor); // 100

//  У самого объекта только одно свойство, но благодаря тому, что мы указали прототип он так же получил и свойства прототипа!
// все это касается и методов
jonh.sayHello(); */


                                    // СОВРЕМЕННЫЙ СПОСОБ Object.setPrototypeOf()  и  Object.create();

Object.setPrototypeOf(jonh,  soldier); // Первый аргумент - это тот кому мы назначаем прототип
                                    // Второй - это сам прототип
jonh.sayHello();

// Это все работа в динамике джон существовал и мы ему установили какой-то прототип
// но обычно это все происходит на этапе создания объекта


const jack = Object.create(soldier); // мы создаем объект jack и сразу назначили ему прототип!

jack.sayHello();

jack.health = 150;  // Все и дальше можем спокойно с ним работать

console.log(jack); //{ health: 150 }
console.log(jonh); // { health: 100 }
// два бравых солдата с разным хп, но одинаковой броней из за их общего прототипа