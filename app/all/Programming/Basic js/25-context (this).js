// короче this - это контекст и он бывает разный, при разных вызовах функции. то есть в разных условиях this может иметь разное значение.
// this - это как человек без опр мества жительства, такой человек функциониурет в пределах всего мира, он и к чему не привязан, так и this
// но если мы его где то поселим, то он уже получит контекст вызова, теперь у него есть свое место для функционирования
// так же можно сказать, что this - это переменная которая ссылается на объект, а какой объект уже зависит от условий функциий

//Ниже разберем при каких условиях контекст будет изменяться

// Очень важный момент если у нас стоит режим use strict, то нам будет выводить undefiend, если режим нету, то получим window

/*
*       1 -  Обычная функция: this = window, но если use strict - undefiend
*/

"use strict";
function showThis (){
    console.log(this); 
}

showThis();


function showThis2 (a,b) {  // создаем функцию с 2 аргументами, 
    console.log(this);

    function sum () { // внутри еще одну функцию
        console.log(this);  // здесь контекст вызова будет такой же либо window либо undefiend
        // return this.a + this.b;  // а что бы застваить работать функцию, нужно сделать замыкание
        return a + b; // просто убираем this. функция не находит переменные a и b здесь и ищет их в функции выше 
    }

    console.log(sum());
}

showThis2(1,2); 


/*
*               2 - Контекст у методов объекта - сам объект
*/

const obj = {  // Объект 
    a:20,
    b:15,
    sum: function() { // внутри метод
        function what () {
            console.log(this); // будет undefiend. Потому что это функция внутри метода, а не сам метод объекта,
            // поэтому тут все так же как было выше
        }
        console.log(this); // контекст будет объектом в котором находится функция
        
    }
};

obj.sum();


/*
*   3 - this в конструкторах и классах - это новый экземпляр объекта
*/


function User (name,age) {  // третий способ с функцией конструктор
    this.name = name; // эти this обращаются к объекту которые мы будем создавать 
    this.age = age;  // Посути вместо this каждый раз подставляется новый экземпляр объекта
    this.human = true; 
    this.hello = function () {
        console.log('hello' + this.name); // здесь this так же ссылается на объект который мы создали и берет его свойство name  
    };
    

    
}

let ivan = new User ('ivan',24);   // this ссылается на этот экземпляр
let dima = new User('Dima', 30); // и теперь на этот. здесь при создании мы сразу передаем значения в наши свойства name и id

dima.hello(); // выдаст (helloDima)


/*
*               4 - Ручная привязка this: call, apply, bind
*/

function sayName(sername) {            // как подвязать этой функции контекст объекта us?
    
    console.log(this);
    console.log(this.name + sername);
    
}


const us = {
    name: 'diman'
};

// Для этого есть два метода и один который сам создает новую функцию

//1)  call()
// просто вызываем у функции метод
sayName.call(us, 'chern'); // здесь аргументы добавляем просто через запятую в ковычках
//2) apply()
// оба  метода делают одно и тоже, но у них разный синтаксис
sayName.apply(us, ['nechern']); // здесб все тоже самое только внутри массива

//3)  bind()

function count(num) {
    return this*num; //  здесь в this будет двойка, мы ее передали ниже
    
}

const double = count.bind(2); // здесь мы по сути поместли в count новую функцию
console.log(double(2));  // а num будет передаваться в double
// мы навсегда забиндили функцию! создали ей ручной контекст ввиде двойки и теперь просто вызываем нашу double и передам нужный аргумент 
console.log(double(10)); // 20



/*
*                           Немного рабоатем с this
*/

//1) Если обработчик с обычной функцией, то this как и event target будет сам элемент события 
const btnThis = document.querySelector('.btn-this');

btnThis.addEventListener('click', function () {
        this.style.backgroundColor = 'red'; // при нажатии перекрасим кнопку в красный, так как this -  элемент события
    // елси же на событии использовать стрелочную функцию, то this будет window или undefiend так как не имеет контекста
});

//2) стрелочные функции. У стрелочных функций нет своего контекста вызова, она будет его брать у родителя

const obj2 = { // наш объект
 num: 2,
 sayNumber : function () { // метод этого объекта
    const say  = () => {
        console.log(this);  // функция внутри метода
    };

    say();
 }

};

obj2.sayNumber(); // контекстом будет объект  {num: 2, sayNumber: ƒ}

// на строчке 46 уже говорилось об этом, Только там была обычная функция
// стрелочная функция без контекста, поэтому она ссылается на родителя sayNumber - метод в свою очередь ссылается на объект
// поэтому наша this внутри say ссылается на сам объект obj2



/*
*                           Сокращение функций
*/
// const double2 = (a) => {
//         return a * 2; 
// };

// стрелочная функция была придуманна, что бы укарачивать наш код
// если действие функции помещается в одну строку, то мы можем написать его без фигурных скобок

const double2 = a => a * 2; // return подставится автоматически если действие помещается в одну строчку
// так же если стрелочная функция принимает только один аргумент, то можно написать без круглых скобок

console.log(double2(4));