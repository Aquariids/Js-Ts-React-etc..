//                               Немноха оОПе

/*
*                           Инкапсуляция, а зачем ПОчему???


инкапсуляция - ето такое понятие в ооп. Оно представляет собой сокрытие состояния объекта от прямого доступа из вне
по умолчанию все свойства объектов являются публичными, общедоступными, и мы к ним можем обратиться из любого места программы

по сути инкапсуляция это сокрытие функций, переменных и прочих внутренностей
В ООП это означает, что объект хранит свое состояние в приватном порядке и только методы объекта имеют доступ для его изменений
*/ 


// создадим функцию конструктор

// function User(name,age) {
//     this.name = name;
//     this.age = age;

//     this.say = function() {
//         console.log(`Имя пользователя:${this.name}, возраст:${this.age}`);
//     };
// }

// const ivan = new User('ivan', 30);   // создадим новый экземпляр

// console.log(ivan.name);
// console.log(ivan.age); // мы можем обращаться
// ivan.name = 'dima'; // но так же мы можем и менять значение свойств объекта
// ivan.age = 18;

// ivan.say();

// вот тут нужна инкапсуляция, что бы нам не могли так нагло переписывать свойства



// function User(name,age) {
//     this.name = name;
//     let userAge = age; // если мы вместо свойства создадим переменную, это уже и будут зачатки инкапсуляции
//      так как мы создали переменную, мы не поменять ее не можем и даже получить
//     и что бы работать с такими переменными нам нужны гетер и сетер. Но немного не тот синтаксис который есть у меня в уроке 03.
//      геттерами и сетарами так же называют любые методы которые позволяют получать либо устанавливать значение.
//     this.say = function() {
//         console.log(`Имя пользователя:${this.name}, возраст:${userAge}`);
//     };
// }

// const ivan = new User('ivan', 30); 
// ivan.userAge = 50;          // не можем поменять

// ivan.say(); // age  будет 30




// function User(name,age) {
//     this.name = name;
//     let userAge = age;
//     this.say = function() {
//         console.log(`Имя пользователя:${this.name}, возраст:${userAge}`);
//     };

//     this.getAge = function () { // создаем функцию которая возвращает нам age
//         return userAge; 
//     };  
//     this.setAge = function (age) {

//         if(typeof(age) === 'number' && age > 0 && age < 110) {
//             userAge = age;
//         } else {
//             console.log('недопустимое значение');
//         }
//     };
// }

// const ivan = new User('ivan', 40);
// теперь для получения возраста у нас есть опр функция и для того что бы его поменять тоже
// console.log(ivan.getAge()); // получаем возраст
// ivan.setAge(30); // меняем возраст
// ivan.setAge(300); // меняем на недопустимое значение
// console.log(ivan.getAge());


// ivan.say();


//  так вот мы и получили нашу инкапсуляцию. Теперь испробуем на КЛАССЕ


// в классах те свойства которые нам нужно скрыть мы добавляем нижнее подчеркивание. Это не синтаксис язык, это договоренность между программистами
//здесь мы уже будем использовать те самые геттеры и сеттеры из урока 3.
// то, что я писал выше по сути старый вариант до геттеров и сетеров
class User{
    constructor(name,age) {
        this.name = name;
        this._age = age;  // let тут не  будет работать. У конструктора тут свое лексическое окружение. Вне него мы не можем получить доступ к переменной
    }

    say() {
        console.log(`Имя пользователя:${this.name}, возраст:${this._age}`);  
    }

    get age() { 
        return this._age; 
    }
    set age(age) {
        if(typeof(age) === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('недопустимое значение');
        }
    }
    
}


const ivan = new User('ivan', 30);

console.log(ivan.age );
ivan.age = 99;
console.log(ivan.age );
ivan.say(); 



