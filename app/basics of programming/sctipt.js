/*
*                           Начало: Тут буду писать о базе, из видосов из CS50 и тд

вычислительно мышление или компьютерное мышление.

это входные данные (проблема которую решаем)
форма представления этих данных(алгоритм) - используются для решения !
и выходные данные которые (ответ который мы хотим найти)
inputs -> algorithms -> outputs

*/



/*
*                           Системы счисления  

Десятичная - это то что мы все знаем и к чему привыкли (0,1,2,3,4,5,6,7,8,9)
в десятичной системе 123 для нас это - Справа единицы в середине десятки слева сотни. Сто двадцать три

по факту это сто раз по одному + десять раз по два и один раз три

в мире компьютеров используется двоичная система

Двоичная - в двоичной систе все состиот из 0 и 1.
Например 0 0 0 - это ноль, здесь не работает как в десятичной сотни в первой колнке потом десятки и единицы кратные 10 короче

а  один и кратные двум 2 4 16 32 и тд
    4 2 1
    0 0 0 - это ноль просто потому что 4 на 0 это 0 + дважды 0 плюс еще ноль и в итоге 0

здесь все рабоатет так
001 - это еденица (0 * 1 = 1)
010 - это два (1 * 2 = 2)
потом последовательность начинает повторяться 

011 - это три ( где 1 * 1 = 1 потом 1 * 2 = 2 Вместе равно 3)

100 - это 4 ( 1 * 4 = 0)
110 - это 6 (1 * 4 = 4 и 1 * 2 = 2 (4 + 2 = 6))
111 - это 7 ( 1 * 4 = 4 потом 1 * 2 = 2 и 1* 1 = 1 сумма 7)
далее нужно больше битов -  Биты это двоичный знак
    то есть это 0 или 1


    128 64 32 16 8 4 2 1
     0  0  0  0  0 0 0 0   - это наши 8 бит (8 нолей это 0)))
     

    восьмерка будет  - 0  0  0  0  1 0 0 0  ( то есть 0 * 1 = 0 потом 0 * 2 = 0 потом 0 * 4 = 0 и 1 * 8 = 8, далее опять  0 так и рабоате все)

    это шестнадцать -  0  0  0  1  0 0 0 0
    
    число 50 например  -   1 1 0 0 1 0 

    число 60 = 00111100
    

    Байты - это восемь бит 0000 0000 - это байт ( 8 бит) у байте может быть 256 значений

    от 00000001 = 1 до 11111111 = 255 вместе с 00000000 = 0 будет 256

    В разном контексте все это имеет разный смысл.
    Например: RGB - цвет красный зеленый и синий (255 255 255) - для каждого цвета свой байт от 0 и до 255 
    где 255 255 255 - это самый белый, скажем так это такая интенсивность и пишется все это в десятичной форме, но за этим находтся биты
    а 0 0 0 это самый черный

Так же мы можем обозначить и буквы

A - в двоичном будет 01000001 -  в десятичном это 65
B - 01000010 - 66


и тд

Все зависит от контекста


*/


/*
*                           Алгоритмы - это набор действий для пошагового решения какой то проблемы

Алгоритмы состоят из инструкций

Есть линейные алгоритмы, когда все идет друг за другом, шаг за шагом
есть циклические алгоритмы, когда дошел до опр шага, потом вернулся и тд
алгоритм ветвления - это когда доходим до опр команды где происходит развилка и мы можем выбрать опр логику
и есть комбинированные это когда все выше сказанное переплитается, так и работает почти все
ё


бинарный поиск  (двоинчый поиск) - это алгоритм привязанный уже к конкретной логической задаче

Например если у нас книга на 1000 имен и мне нужно найти кого то, не нужно использовать линейный поиск

Это может занять 1000 операций, Легче открыть середину 500 потом опять поделить и будет 250, потом 125

мы просто уменьшаем объем работы и если нужно имя было например под номером 100 по линейному поиску это 100 операций
по бинарному это 7 операций. мы каждый ращ откусываем половину

Операторы, функции - 

Все состоит из операторов или функции или процедуры
это просто действия - делай так
например в жизни, когда мы видим что идет дождь мы принимаем решение взять зонт 
Это и есть наш условный оператор (Если идет дождь нужно взять зонт) - какое то условие и действие

Циклы - это повтор команды.

Например наш бинарный поиск обыными словами

1: взять тел книгу
2: открыть ее на середине
3: посмотреть на имена
4: если есть нужное нам имя   
5: позвонить ему
6: иначе если наше имя ранее
7: открыть левую часть книги на середине
8: вернуться на 3 строку
9: иначе если наше имя дальше
10: Открыть правую часть на середине
11: вернуться на строку 3
12: иначе
13: бросить поиск


4 6 9  и 12 это наши условия, Они там где нужны решения, они позволяют делать что то при опр условиях
это и есть наш условный оператор

строки  8 и 11 это наш цикл

*/

const array = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; // здесь мы будем искать 7
let count = 0; // счетчик наших действий
// нам нужно получить центральный элемент нашего массива

function binarySearch(array,item) {
    let start = 0; // это позиция нашего первого элемента
    let end = array.length; // это позиция последнего элемента(вычесляется по длине массива)
    let middle; // среднйи элемент будет высчитывать  в цикле

    // так же нужно две вспомогательные переменные
    let found = false;  // это переменная  помогает понять нашли мы элемент или нет, некий такой флаг
    let position = -1; // позиция элемента которую мы будем возвращать из функции, если элемент не найдн мы будем возвращать -1
    while(found === false && start <= end) { // цикл будет работать до тех пор пока мы не нашли элемент это наш false в found или же пока начальная и конечная позиция не поровняются
        middle = Math.floor((start + end) / 2); // с помощью floor избавляемся от нецелы чисел.
        // здесь мы выщитываем позицию центрального элемента( стартовую складываем с конечной и делим на 2)
        // далее проверяем(если элемент находящийся в массиву по индексу который мы посчиатли равен тому элементу который мы ищем)
        // found ставим true и устанавливаем позицию
        count++; // считаем кол итераций
        if(array[middle] === item) {
            found = true;
            position = middle;
            return position; // останавливаем цикл
        }

        if (item < array[middle]) { // если нужный нам элемент меньше чем элемент который находится в самой середине, то нам нужна только левая часть массива
            // так как искомый элемент меньше чем центральный

            end = middle - 1; // мы присваевам в поз посл элемента наш центральный и - 1

        } else { // иначе если искомый элемент больше, делаем на оборот
            start = middle + 1;
        }
    }

    return position;
}



console.log(binarySearch(array,8));  // Восьмерку мы нашли за 1 итерацию
console.log(count);

// тут мы разобрали ток бинарный поиск. Все полезные алгоритмы мы разберем отдельно. (КТО МЫ БЛЯТЬ? Я ТУТ ОДИН)

