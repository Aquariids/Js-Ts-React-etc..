// Сортировка выбором.!

// В цикле находим минимальное значение, затем меняем местами с первым элементом.
// далее мы опять ищем минимальное значение, но меняем уже со вторым элементом и тд


const arr = [9,2,3,5,9,1,10,58,-10,-20,7,120]; // массив который нужно отсортировать. 

console.log(arr.length);
let count = 0; // наше кол операций


function selectionSort(arr) { 
    for(let i = 0; i < arr.length; i++) {
                // рассматриваю все на примере первой итерации.
        let indexMin = i; //  в первой итерации тут 0 

        for(let j = i+1; j < arr.length; j++) { // запускается внутренний цикл
            // этот цикл не закончится пока j меньше кол эл в массиве.
            if(arr[j] < arr[indexMin]) {  
                // (1 итерация внутреннего цикла: если arr[j] меньше чем arr[indexMin] В случае первой итерации это 2 и 9.
                indexMin = j; // 2 меньше чем 9. Поэтому в IndexMin кладем j. В j у нас сейчас 1.
                // (2 итерация внут цикла) далее в j прибавляется еще еденица и получается j = 2, а indexMin = 1, так как в прошлой ит мы поменяли indexMin на j
                // теперь мы в условии проверяем 2 и 3. Три не меньше двух условие не срабатывает и идем к след итерации внут цикла.
                // (3 итерация): в indexMin у нас все еще 1,а j + 1 = 3.
                // проверяем под 5 меньше чем 2? нет, идет след итер
                // (4 итерация): indexMin(1) а j(4).
                // проверяем 9 меньше чем 2? нет. след итер
                //(5 итерация): indexMin(1), j(5)
                // 1 меньше чем 2? Да. Теперь в indexMin(1) = помещаем j(5) и идем дальше
                //(6 итерация ): indexMin(5), в j(6) и проверяем 10 меньше чем 1? нет
                // (7 итерация):  indexMin(5), в j(7). 58 меньше чем 2? нет
                //(8 итерация): и последняя, так как в j уже последний элемент.
                // в indexMin(5) в массиве это 1 а в j(8) это -10
                // -10 меньше чем 1? ДА
                // помещаем в indexMin(5) = j(8). Теперь в indexMin = 8
                // j + 1 = 9. 9 не меньше чем arr.length(9) и конец цикла.
                // выходим из внутреннего цикла и возвращаемся в конец первой итерации основного цикла
            }
            count += 1; // кол операций
            
        }
        
        let tmp = arr[i]; // далее в tmp кладем arr[i]. i = 0, то есть кладем первый элемент в tmp в массиве это 9
        arr[i] = arr[indexMin]; // потом на место первого кладем последний минимальный indexMin у нас 8,  8 в массиве это -10.
        // Мы заменяем первый элемент arr[i] = 9 на последний минимальный  arr[indexMin] = -10
        arr[indexMin] = tmp; // после в indexMin кладем первый элемент.
        // Таким образом, после первой итерации на месте первого элемента у нас находится -10, а 9 в конце
        // Во внутреннем цикле теперь итераций будет на 1 меньше,так как i теперь 1, а j = i + 1 то есть 2.
        // первый элемент -10  у нас минимальный и он больше никем не трогается.
        // потом начинается след итерация основного цикла и внутренний будет делать уже 7 итерация, а не 8
        
    }

    return arr;
}


console.log(selectionSort(arr));
console.log(count); // 66 итераций на массив из 12 элементов. 
// сложность алгоритма O(n * n) n в квадрате. так как 12 элементов в квадрате это 144, а в нашем случае - 
//  скорее  O(1/2 n*) но в O большом нет кофициентов, поэтому просто O(n*n)
