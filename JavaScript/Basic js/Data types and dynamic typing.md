[Примитивные типы данных в Javascript](#DataTypes)<br>
[Комплексный тип данных 'Object'](#object)<br>
[Динамическая типизация в JavaScript](#dinamic)<br>
[Неявное приведение типов данных](#typesIntypes)<br>




Для проверки переменных и значений на их тип данных, в js есть метод `typeof(*тут переменная или значение*)`
```javascript
'use strict';

let num = 10;

console.log(typeof(num)) // number
console.log(typeof('строка')); // string
```
Далее я буду пользоваться этим методом для наглядной демонстрации типа данных.



## <a name ='DataTypes'> Примитивные типы данных </a> ## 

В js существует восемь типов данных. Из них семь примитивов и один комплексный, более сложный тип данных(объект).<br>
Примитив - это тип данных с простым значением, строка, число, булевое значение или что-то еще.<br>
Разберем все по порядку.

## Число(number) ####
Это обычные цифры, числа. Максимальное допустимое число для безопасной работы в javaScript 2<sup>53</sup> степени.
Так же кроме обычных чисел есть специальные значения: `Infinity`, `-Infinity` и `NaN`.
```javascript
'use strict';

let numbers = 12;

console.log(typeof(numbers)); //number
```
#### infinity и -infinity  (Бесконечность) ####
```javaScript
'use strict';

console.log(4 / 0); // Infinity
console.log(-4 / 0); // -Infinity
```
#### NaN(Not a Number) ####<br>
`NaN` будем получать при ошибочных метематических операциях. Например умножаем то, что умножать нельзя:
```javaScript
'use strict';

console.log(4 * 's')// NaN
// Умножаем число на строку, получаем NaN
```
## Строка(String) ##
Строки всегда в одинарных или двойных кавычках `''` `""`.
```javascript
'use strict';

let str = 'привет'
let str2 = '12' // это строка

console.log(typeof(str)); // string
```
## Логический тип(boolean) ##
Булевый тип принимает только два значения: `true`(истина) и `false`(ложь). [Используется для работы с условиями.](https://github.com/Aquariids/Js-Ts-React-etc../blob/main/JavaScript/Basic%20js/if%20and%20switch.md)
```javascript
'use strict';

let booleanTypes1 = true; 
let booleanTypes2 = false;

console.log(typeof(booleanTypes1,booleanTypes2)); // boolean
```
## null ##
`null` - это отдельный тип данных, который содержит в себе только `null`. Он подразумевает отсутствие объектного значения.<br>
`null` - это простой тип данных, но при этом от `null` унаследованы все объекты. Если проверять тип `null` то выдаст `'object'`. 
```javascript
'use strict';

let a = null;
console.log(a); // null
```
## undefined ##
undefiend - присваивается переменным, которые были только объявлены, без значения. Так же аргументам в функциях, для которых не были установлены значения.
```javascript
'use strict';

let a;
console.log(a); // undefined
function f1 (a,b) {
    console.log(a);
}

f1(); //undefined
```
## Символ(Symbol) ##
Тип `symbol` (символ) используется для создания уникальных идентификаторов в объектах.
Я его еще не изучал, так шо сории.

## BigInt ##
`BigInt` позволяет работать с числами больше чем 2<sup>53</sup>степени.
`BigInt` создаётся путём добавления n в конец целочисленного литерала или вызова функции `BigInt()`.
```javascript
'use strict';

let theBiggestInt = 9007199254740991n;
let alsoHuge = BigInt(9007199254740991);
// документация MDN привет
```

## <a name ='object'> Комплексный тип данных (Object) </a> ##                                 
  Объект - это структура данных которая может иметь в себе разные данные. Именно потому что объект может содержать в себе разные конструкции, он не относится к примитивам.
  При этом эти данные могут быть разного типа, это благодаря динамической типизации языка.(О ней будет ниже)
  ```javaScript
  'use strict';
  
    // этот объект содержит в себе определенные свойства(своеобразные переменные).
    // Любое свойство подразумевает пару "ключ(имя):значение(что угодно)", обязательно ставим двоеточие.
   
   const obj = {  // Создав переменную просто открываем фигурные скобки {}. Так, мы создали объект. 
     name: 'Dima',  // свойство  с ключом name со значением Dima
     age: 24, // свойство с ключом age со значением 24 и тд. 
     watchAnime: true 
     // Идут свойства через запятую, у последнего свойства ставить запятую не нужно.
  }
  // проверим на тип данных
  console.log(typeof(obj));// object
  // Что бы обратиться к свойству в объекте, пишем имя объекта и через точку свойство. Проверим тип данных свойства name
  console.log(typeof(obj.name)); // string ('Dima' - это строка)
  ```
  Комплексный он потому что на основе объекта могут быть разные конструкции(Специальные объекты)
  
  ## Специальные объекты ##
  #### Массив ####
  Массив это частный случай объекта. Он как бы в своей основе объект, но немного с другим поведением. Все данные хранятся строго по порядку!
  ```javaScript
  'use strict';
  // создав переменную прописываем квадртаные скобки []. Все, массив готов.
  const arr = ['ss', 1, {}, []]; // Массив как и объект так же может содержать в себе разные типы.
  
// Но здесь есть только значения, а Его ключи они фиксированны и идут строго по порядку от 0 - это индекс(позиция элемента)
// Например строка 'ss' - она первая и ее индекс(позиция) будет 0, далее число 1 с индексом 1 и так далее.
// В программировании все начинается с 0 (Первый элемент это всегда позиция 0).
// проверим позицию элемента (просто указываем массив и нужный индекс в квадратных скобках []).

console.log(arr[0]); // нам выдаст 'ss'

// проверим тип данных массива

console.log(typeof(arr)); // object

// проверим тип данных элемента под индексом 0

console.log(typeof(arr[0])); // string (потому что там строка 'ss')
  ```
  #### Функции ####

О  работе функциях я буду говорить не здесь. Пока просто проверим тип данных функции.
Мы получим `function`. Это техническая часть, углубляться пока что нет смысла. Но функция это специальный объект, просто так же имеет свой специальный тип вот и все.
```javaScript
'use strict';

const f1 function () {
return;
};

console.log(typeof(f1)) // function
```


#### Объект даты ####
С объектом даты так же будем работать позже.
``` javaScript
'use strict';

let now = new Date();

console.log(typeof(now)); // object
```
#### Регулярные выражения и ошибки ####
И с этими понятиями познакомимся позже
```javaScript 
'use strict';

let reg = /i/g // регулярное выражение

console.log(typeof(reg)); // object

let err = new Error(); // объект ошибки

console.log(typeof(err)); // object
```
## <a name ='dinamic'> Динамическая типизация </a> ## 
Типизация - подразумевает классификацию типов данных.<br>
Динамическая типизация - это когда тип данных задается(классифицируется) при присваивании значения:

```javaScript
let num = 1; // JavaScript понимает, что здесь тип данных числовой, при добавлении в переменную значения.
// Это и есть Динамическая типизация, то есть она меняется в динамике.
```
Так же стоит упомянуть, что есть статическая типизация.<br>
Статическая типизация - это когда язык проверяет тип данных в программе во время компиляции, еще до запуска программы. 
То есть мы указываем тип во время объявления переменной<br>


## <a name ='typesIntypes'> Неявное приведение типов в JavaScript </a> ##
Так же динамическая типизация подразумевает неявное приведение типов. 
Неявнное приведение типов - это автоматическое приведение типа, выполняемое компилятором.
То есть когда мы это делаем неявно, не каким то специальным методом.

#### String ####
Привести к строке можно с помощью конкатенации(Это склеивание строк вместе).<br>
Конкатенация - сложение строк или строки с чем то(для этого используется математический `+`).        
```javaScript
console.log(typeof(5 + '')); // string
// Мы сложили число с пустой строкой. В итоге получили '5' - строку
console.log(typeof(undefined + '')); //string 
// Получили  'undefined' - строка
// так же можно и не с пустой строкой. Допустим добавляем через js какие то стили и нам нужно 25px
console.log(25 + 'px')); // 25px - это строка
```
Пустые массивы в операциях с конкатенацией равняются путой строке
```javaScript
 console.log(typeof([]+[])); // string
 console.log([] + 5); // даст строку '5'
 console.log(typeof({}+{})); // string
 // объект тоже превращает в строку. Но при конкатенации объект не равен пустой строке, он будет выдавать [object Object] (просто строчное представления объекта)
 console.log({} + 5); // [object Object]5
  //  Это все приведет к строке и типу данных string. Но не получится как с помощью массива превратить 5 в "5".
```  
#### Numbers #### 
К числу приводит унарный `+` это довольно частый способ.
```javaScript
    console.log(typeof(+ '5'));  // number
    let answ = +prompt('num?','');  // мы введем число(Все что мы получаем от пользователя это всегда будут строки)
    // Так вот, мы ввели число допустим 100. В prompt передалась строка '100', далее унарный + привел '100' к числу 100
```
К числу приводят операторы сравнения `>`, `<`, `<=`, `>=`.
```javaScript
    console.log(3 > '1') // вернет true.
    // js сам взял строку '1' и привел ее к числовому типу, а потом выполнил сравнение
```
Так же и арифметические операторы `-`, `*`, `/`, `%`. Кроме `+` с двумя операндами(конкатенация).
```javaScript
    console.log('3' - 2) // 1
    // js привел строку '3' в числовой тип и отнял 2. Получаем цифру 1
    // но с + произошла конкатенация
    console.log(3 + '3'); // 33 
```
#### Boolean #### 
Важно запомнить значения и типы которые приводят к логическому типу.                                   
Добавим в массив все, что превращается в `false`
```javaScript
const itIsFalse [0,'',null,undefiend,NaN]; // все это приведет в условии к false
// если мы получаем false, то условие не будет выполнено, если true - будет.
if(0 == '') {
console.log('0')
} // это условие сработает, так как 0 - false и '' тоже false. false равно false? да, получим true. Об условиях тоже позже. 
let switcher = null;
  if (switcher) { // не сработает, так как в переменной null.
    console.log('working...');
  }
// так же довольно часто используется подобный синтаксис:
if(argument) { // мы передаем некий аргумент(если внутри функции например)или переменную. Если она пуста, код не выполнится, так как там будет undefiend.
console.log('я что-то cделаю если в переменной, что-то будет')
}
```
Все остальное будет `true`. Любая цифра или число кроме `0`, любая строка кроме пустой `''`. 
Так же любой объект в логическом контексте – `true`, даже если это пустой массив `[]` или объект `{}` 
  ```javaScript
  if ({} && []) {
   console.log("Все объекты - true!"); // код сработает.
  } 
  ```
 Логические операторы`!`,`!!`, `&&`, `||`
 ```javaScript
  console.log(typeof(!!'42432')); // boolean
  console.log(2 || '')  // 2
  // оператор или || и оператор && вернут числа. Но для этого они неявно преобразует их в логический тип. 
  console.log('he' && 12) // 12
  // Когда мы будем говорить про операторы, то все станет более ясно.
```

- [*Консоль разработчика и общение с пользователем*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Browser%20Methods%20and%20console.md 'Консоль разработчика и общение с пользователем')<br>
- [*Строгий режим (Strict mode)*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/use%20strict.md 'Строгий режим в js')<br>
- [*Переменные*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Variables.md 'переменные')<br>
- [*Интерполяция*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Interpolation.md 'Интерполяция')<br>
- [*Операторы*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Operators.md 'Операторы')<br>
- [*Условные операторы*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/if%20and%20switch.md 'Условные операторы')<br>
- [*Циклы*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/While%20and%20for.md 'Циклы')<br>
- [*Функции*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Functions.md 'Функции')<br>
- [*Callback функции*](https://github.com/Aquariids/MyJS/blob/main/app/Programming/Basic%20js/Callback%20functions.md 'callback функции')<br>

